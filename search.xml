<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker 编译Android源码]]></title>
    <url>%2F2018%2F02%2F26%2FDocker-%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Windows 安装Docker Cannot install packages inside docker Ubuntu image 1234567891011It is because there is no package cache in the image, you need to run:apt-get -qq updatebefore installing packages, and if your command is in a Dockerfile, you&apos;ll then need:apt-get -qq -y install curlAlways combine RUN apt-get update with apt-get install in the same RUN statement, for exampleRUN apt-get update &amp;&amp; apt-get install -y package-bar 参考使用Docker编译Android系统源码 Ubuntu14.10 编译 Android5.0 源码 更换系统镜像源 apt-get install wget wget 网址而要让档案自动储存到指令的目录下，则需要借用-P这个参数，可以使用以下的指令 wget -P 目录 网址举例来说，如果你要放到/root底下，你可以打下列的指令：wget -P /root 网址 安装配置openjdk-7-jre 123456789vim/gedit ~/.bashrcexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/bin/tools.jar:$JRE_HOME/binexport ANDROID_JAVA_HOME=$JAVA_HOMEexport USE_CCACHE=1source ~/.bashrc 安装其他工具 12345678910111213141516dpkg --print-architecture # 若支持，输出 amd64dpkg --print-foreign-architectures # 若支持，输出 i386//手动开启支持dpkg --add-architecture i386apt-get updatesudo apt-get install gcc-multilib g++-multilib build-essentialsudo apt-get install git-core gnupg bison flex gperf pngcrush bc zip curl lzopsudo apt-get install schedtool libxml2 libxml2-utils xsltproc squashfs-toolssudo apt-get install libesd0-dev libsdl1.2-dev libwxgtk2.8-dev libswitch-perlsudo apt-get install libssl1.0.0 libssl-dev lib32readline-gplv2-dev libncurses5-devcd /AOSPexport USE_CCACHE=1export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccacheprebuilts/misc/linux-x86/ccache/ccache -M 50G windows 上创建/androidsource git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git输入命令，切换到manifest目录 cd manifest Git tag 列出android各个分支版本下载android-android-5.1.1_r9git checkout android-5.1.1_r9 运行 python download-src.py 1234567891011121314151617181920212223242526272829import xml.dom.minidom import os from subprocess import call #downloaded source path rootdir = &quot;E:/androidsource&quot; #git program path git = &quot;D:/Git/bin/git.exe&quot;dom = xml.dom.minidom.parse(&quot;E:/androidsource/manifest/default.xml&quot;) root = dom.documentElementprefix = git + &quot; clone https://aosp.tuna.tsinghua.edu.cn/&quot; suffix = &quot;.git&quot; if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName(&quot;project&quot;): os.chdir(rootdir) d = node.getAttribute(&quot;path&quot;) last = d.rfind(&quot;/&quot;) if last != -1: d = rootdir + &quot;/&quot; + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute(&quot;name&quot;) + suffix call(cmd) 出现 curl: (22) The requested URL returned error: 404 Not Found Server does not provide clone.bundle; ignoring. 怎么办？无视即可 下载repo 123456789101112131415161718192021mkdir ~/binPATH=~/bin:$PATHcurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo(或者下面的地址)curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repochmod a+x reporepo的运行过程中会尝试访问官方的git源更新自己，如果想可以使用[tuna的镜像](https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/)源进行更新，可以将如下内容复制到你的~/.bashrc里export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;并重启终端模拟器cd /AOSP初始化同步reporepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-5.1.1_r9repo sync -f -j4AOSP 未下完成是不显示文件，.repo是隐藏文件夹，ctrl+h显示有问题时删除缓存文件rm -rf * -R 设置repo环境变量 123vim ~/.bashrcexport PATH=~/bin:$PATHsource ~/.bashrc Ubuntu 下载源码 start a shell session in a running container 12345docker exec -it 98e0b4f60ec3 bash$ sudo docker attach 665b4a1e17b6 #by ID or$ sudo docker attach loving_heisenberg #by Name$ root@665b4a1e17b6:/# Android系统源代码的下载与编译 初始化源码所需环境变量和参数 1source build/envsetup.sh lunch 命令选择编译目标 出现error build/core/java.mk 33: *** cts/apps/CtsVerifier: Invalid LOCAL_SDK_VERSION ‘current’ Choices are: . prebuilts缺少文件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 c++]]></title>
    <url>%2F2018%2F02%2F26%2F%E7%AE%97%E6%B3%95-c%2F</url>
    <content type="text"></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes]]></title>
    <url>%2F2018%2F02%2F25%2FAndroid-%E7%BE%A4%E8%8B%B1%E4%BC%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Android系统架构 Android系统分四层：Linux内核层，库和运行时，Framework层和应用层。 Linux包括硬件驱动，进程管理，安全系统 Dalvik虚拟机，运行时编译；ART虚拟机安装时编译 Framework ActivityManager BackupManager Bluetooth ContentProviders LocationManger Map libraries MediaPlayer NotificationManager PackageManager ResourceManager SearchManager SharedPreference TelephoneManager WidgetProvider WindowManager ViewSystem XMPPService 标准库 Apache HTTP OpenGL ES Open SSL SQLite Webkit ICU Android NDK/SDK APP(解压后包含内容中有) AndroidManifeset Dalvik Classes Resource bundle NDK APP中包含JNI lib App组件 Activity BroardCastReceiver ContentProvider Service Context Application Context(应用启动时创建，整个生命周期) Activity Context Service Context Android 源代码目录与系统目录 Android源代码目录 Makefile (自动化编译，定制规则) bionic (bionic C库) bootable (启动引导相关代码) build (系统编译规则等基础开发包配置) cts (Google兼容性测试标准) dalvik (dalvik虚拟机) development (应用程序开发) external (开源模块) frameworks (框架) hardware (硬件适配层HAL代码) out (编译完成后代码输出目录) packages (应用程序包) prebuilt (x86 arm 架构下预编译资源) sdk system (底层文件系统库，应用及组件) vendor (厂商定制代码) Android 系统目录 (ADB ls命令查看系统目录) /system/app/ 系统app /system/bin/ Linux自带组件 /system/build.prop/ 系统属性信息 /system/fonts/ 字体 /system/framework/ 核心文件，框架层 /system/lib/ .so文件 /system/media/ 音频，闹钟，短信，来电等铃声 /system/usr/ 用户配置文件，键盘布局，共享，时区文件 /data/app/ 安装或升级的app /data/data/ App数据文件，数据库等信息 /data/system/ 系统信息 /data/misc/ WIFI，蓝牙，签名，VPN等信息 Android 开发工具 SDK镜像地址 android-studio Genymotion 安装arm架构Genymotion-ARM-Translation Android Debug ADB Command (SDK platform-tools) adb shell ls|grep “data” / cd data android list target 显示系统Android平台 id:1 or android-19 adb install -r a.apk 重新安装保留数据，安装位置/data/local/tmp/a.apk adb push a.apk /system/app 文件写入存储系统，有权限时可以安装系统应用 adb push /system/temp/ c:\Desktop 从手机获取文件 adb shell -&gt; logcat|grep “abc” 查看log adb remount(重新挂载系统分区，使系统分区重新可写) -&gt; adb shell -&gt; cd system/app -&gt; rm a.apk adb shell df 查看系统盘符 adb shell pm list packages -f 输出所有安装应用 adb shell input keyevent 3 模拟按键输入 keycode adb shell input touchscreen swipe 18 655 18 500 模拟滑动输入 adb shell dumpsys activity activities|grep “tencent” 列出activity 运行状态，过滤”tencent” pm list packages -f 列出所有package adb shell am start -n com.qiyi.video/org.qiyi.android.video.MainActivity 启动一个Activity adb shell screenrecord /sdcard/a.mp4 录制屏幕 adb reboot 重启 adb 命令来源 /frameworks/base/cmds/ /system/core/toolbox/ Android 自定义控件 控件架构 ContentView id为content的FrameLayout, onCreate()方法中调用setContentView()后ActivityManagerService会回调onResume()，此时系统才会把DecorView添加到PhoneWindow中，显示并完成绘制 View的测量 onMeasure() MeasureSpec 32位int值，高2位为测量的模式，低30位为测量的大小 EXACTLY 精确值模式，具体数值 AT_MOST 最大值模式，尺寸不超过父控件允许的最大尺寸 UNSPECIFIED 不指定，自定义view时使用,如果View要支持wrap_content,重写onMeasure()指定wrap_content时的大小 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 123456789101112131415161718/** * 宽高值自定义，在wrap_content时如果没有指定大小就会默认填充整个父布局 */private int measureWidth(int measureSpec)&#123; int result=0; int specMode=MeasureSpec.getMoode(measureSpec); int specSize=MeasureSpec.getSize(measureSpec); if(specMode=MeasureSpec.EXACTLY)&#123; result=specSize; &#125;else&#123; result=200; if(specMode=MeasureSpec.AT_MOST)&#123; result=Math.min(result,specSize) &#125; &#125; return result;&#125; View的绘制 重写onDraw(Canvas canvas) Canvas 画板1234567canvas.drawBitmap(bitmap1,0,0,null);canvas.drawBitmap(bitmap2,0,0,null);装载画布Canvas mCanvas=new Canvas(bitmap2);mCanvas.drawXXX刷新view的时候，bitmap2发生改变，没有把图形直接绘制在canvas,而是通过改变bitmap2绘制复杂图形，绘制多个拆分的小图形单元 ViewGroup的测量在wrap_content时遍历子View的大小，决定自己的大小，其他模式下通过具体的指定值设置大小。遍历子View，调用子View的Measure方法获得每一个子View 的测量结果，然后遍历子View进行布局Layout,重写onLayout()控制子View显示位置的逻辑，如果支持wrap_content需要重写onMeasure() ViewGroup的绘制 绘制背景颜色以及遍历子View的绘制 自定义View比较重要的回调方法 onFinishInflate() onSizeChanged() onMeasure() onLayout() onDraw() onTouchEvent() 对原生控件扩展 改变绘制顺序，需要改变画布位置状态时，先保存状态，等改变后，再恢复 12345....canvas.save();canvas.translate(10,0);super.onDraw(canvas);canvas.restore(); LinearGradient,Matrix实项文字闪动效果，onSizeChanged()中初始化，根据宽度设置LinearGradient渐变渲染器 1234567891011121314151617181920212223242526protected void onSizeChanged(int w,int h,int oldw,int oldh)&#123; super.onSizeChanged(w,h,oldw,oldh); if(mViewWidth==0)&#123; mViewWidth=getMeasureWidth(); if(mViewWidth&gt;0)&#123; //获取Paint,设置LinearGradient mPaint=getPaint(); mLinearGradient=new LinearGradient(0,0,mViewWidth,0,new int[] &#123;Color.BLUE,Color.RED&#125;,null,Shader.TitleMode.CLAMP); //设置着色器 mPaint.setShader(mLinearGradient) //平移变换矩阵 mGradientMatrix=new Matrix(); &#125; &#125; &#125;public void onDraw(Canvas canvas)&#123; if(mGradientMatrix!=null)&#123; mTranslate+=mViewWidth/5; if(mTranslate&gt;2*mViewWidth)&#123; mTranslate=-mViewWidth; &#125; mGradientMatrix.setTranslate(mTranslate,0); mLinearGradient.setLocalMatrix(mGradientMatrix); postInvalidateDelayed(100); &#125;&#125; 复合控件继承ViewGroup 定义属性 res/value/attrs.xml 123456789101112&lt;declare-styleable name=&quot;V&quot;&gt; &lt;attr name=&quot;title|size|background&quot; format=&quot;string|dimension| reference|color&quot;/&gt;&lt;/declare-styleable&gt;//获取TypedArray,存储了属性值TypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.V);ta.getColor();ta.getString();ta.getDrawable();ta.getDimension();//资源回收ta.recycle(); 组合控件 12345678mBtn1=new Button();mBtn2=new Button();mTextView=new TextView();mParams=new LayoutParams();mParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,true);addView(mBtn1,mParams);addView(mBtn2,mParams);addView(mTextView,mParams); 定义接口,添加事件 public method include layout 重写View 比例图 中间圆形加中心文字，外圈一定比例的圆弧 length 正方形边长 1234567891011- 圆 mCircle=length/2；mRadius=length/4; drawCirle()- 圆弧//所处的矩形框mRect=new Rect(0.1*length,0.1*length,0.9*length,0.9*length);drawArc(mRect,270,mSweepAngle,false,mArcPaint);- 文字drawText();setSweepValue(100); 音频条形图 onSizeChanged()设置渐变色 onDraw() 绘制多个小矩形 postInvalidateDelayed(300) 123456789101112131415161718192021222324252627282930@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); Log.e(&quot;Audio&quot;, &quot;mWidth=&quot; + mWidth + &quot; w=&quot; + w + &quot; h=&quot; + h + &quot; oldw=&quot; + oldw + &quot; oldh=&quot; + oldh); mRectHeight = getHeight(); mRectWidth = (int) (mWidth * 0.6 / mCount); mLinearGradient = new LinearGradient(0, 0, mRectWidth, mRectHeight, Color.YELLOW, Color.RED, Shader.TileMode.CLAMP); mMatrix = new Matrix(); mPaint.setShader(mLinearGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mTranslate += mRectWidth / 5; if (mTranslate &gt; 2 * mRectWidth) &#123; mTranslate = -mRectWidth; &#125; mMatrix.setTranslate(mTranslate, 0); mLinearGradient.setLocalMatrix(mMatrix); for (int i = 0; i &lt; mCount; i++) &#123; mCurrentHeight = (float) (mRectHeight * Math.random()); canvas.drawRect((float) (mWidth * 0.2 + offset + mRectWidth * i), mCurrentHeight, (float) (mWidth * 0.2 + mRectWidth * (i + 1)), mRectHeight, mPaint); &#125; postInvalidateDelayed(300);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sh 简单程序]]></title>
    <url>%2F2018%2F02%2F24%2Fsh-%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sh-demo 直接执行命令123datewho 创建变量，如果是字符串的话，有空格的一定要用双引号，否则会被解析成命令123NDK=10text=&quot;i love you&quot; 命令的执行结果作为变量的值，例如以当前时间作为文件名123text1=datetext2=$(who) 输出1234567echo $NDKecho $textecho $text1echo $text2 字符串拼接，同理：有空格需要用双引号1echo &quot;$text very much&quot; 如果需要输出$的话，需要使用转义字符1echo &quot;$&quot; 运行两种方式 1 ./bash.sh 2 sh bash.sh 如果sh command not found 或者 sh cannot open file 程序中的/r/n 换行符限制 命令退出的状态 命令执行退出的状态： 0 成功 127 没有找到命令 1 未知错误 126 命令不可执行 查看与退出状态指定： 查看上一次命令的执行状态echo $?在shell脚本中，自己指定退出的状态exit 状态码 grep命令是查找命令，例如查找test文本在test.txt中所在的行数：grep -n test test.txt 可以结合test命令，如果条件成立，test命令以状态为0退出，if条件成立。 test命令简单形式，用中括号，注意空格要加上 a -gt b 要加上空格,程序才能运行 比较大小： #!/bin/bash a=10b=5 test命令简单形式 if [ a -gt b ] then echo &quot;a greater than b&quot; else echo &quot;a smaller than b&quot; fi test数值比较： -gt 大于 -eq 等于 -le 小于 -ne 不等于 判空： #!/bin/bash str1=””if [ str1 = “” ] then echo &quot;有内容&quot;else echo &quot;没内容&quot;fi test字符串比较： str1 == str2 str1 != str2 str1 &lt; str2 -n str1 长度是否非0 -z str1 长度是否为0 检查目录是否存在： #!/bin/bash mydir=/usr/jason -d检查目录是否存在 if [ -d $mydir ] then echo &quot;$mydir exist&quot; cd $mydir ls else echo &quot;mydir not exist&quot; fi test文件比较： -d 检查是否存在，并且是一个目录 -e 检查file是否存在 -f 检查是否存在，并且是一个文件 -r 检查是否存在，并且可读，余此类推：-w、-x file1 -nt file2 file1比file2新 file1 -ot file2 file1比file2旧 case语句 基本格式是： case命令case 变量 inpattern1) 命令;;pattern2) 命令;;*) 默认命令;;esac 例子： #!/bin/bash testuser=rose case $testuser in rose) echo &quot;hi,$testuser&quot;;; ricky) echo &quot;hello, ricky&quot;;; *) echo &quot;defaults&quot;;; esac While循环 基本格式： while test command（或者[]）do 命令done 例子： #!/bin/bash a=10 while [ $a -gt 0 ] do echo &quot;num:$a&quot; 赋值不用使用$符号 a=[ a - 1 ]done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用快捷键 命令 设置等操作]]></title>
    <url>%2F2018%2F02%2F24%2FLinux-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键 Ctrl+Alt+T 打开终端 Ctrl+L 清空屏幕(功能相当于命令clear) Ctrl+U 剪切文本直到行的起始(可以用于清空行) Ctrl+K 剪切文本直到行的末尾 Ctrl+Y 粘贴最近剪切的文本 Ctrl+C 杀死当前进程(也可以用来清空当前行) Ctrl+D 退出当前Shell(功能相当于命令exit) 或者 删除当前的字符 Ctrl+A 行首 Ctrl+E 行尾 Home/End 行首/行尾 Ctrl+F 向前移动一个字符 Ctrl+B 向后移动一个字符 Ctrl+P 或 Ctrl+N 上下历史记录 上下方向键 上下历史记录 Ctrl+Shift+C 复制 Ctrl+Shift+V 粘贴 还有Tab补全,按住Ctrl键进行块选择. 鼠标中键:粘贴(在gnome-terminal中使用”菜单 键+P”也是可以粘贴的) 设置代理1.通过export http代理使用apt-get（临时有效）在使用apt-get之前，在终端中输入以下命令 12export http_proxy=&quot;&quot;export https_proxy=&quot;&quot; 2.apt.conf文件中配置http代理信息（永久有效） sudo gedit /etc/apt/apt.conf在您的apt.conf文件中加入下面这行1Acquire::http::Proxy &quot;http://proxy_addr:proxy_port&quot;; 3..bashrc文件中配置代理信息(apt-get, wget 等等)（全局有效） gedit ~/.bashrc 在.bashrc文件末尾添加如下内容1export http_proxy=&quot;http://proxy_addr:proxy_port&quot; vi操作 跳到文本的最后一行：按“G”,即“shift+g” 跳到最后一行的最后一个字符 ： 先重复1的操作即按“G”，之后按“$”键，即“shift+4”。 跳到第一行的第一个字符：先按两次“g”， 跳转到当前行的第一个字符：在当前行按“0”。 vi加密。进入vi，输入”:” + “X” 之后就提示你输入两次密码。之后:wq 保存退出。再次进入时就提示你输入密码了。如果你不想要密码了，就:X 提示你输入密码时连续按两次回车 编辑只读文件存在历史，buffer状态等，不能直接修改保存文件，解决方案1:w !sudo tee % 设置环境变量12345678910111213141516vim .bashrc echo $PATH (列出所有环境变量) echo $JAVA_HOME （列出某个环境变量值） source .bashrc (保存并且生效) NDKROOT=&apos;/home/willkernel/Downloads/android-ndk-r15c&apos;export NDKROOTexport PATH=$NDKROOT:$PATHANDROID=&apos;/home/willkernel/Downloads/android-studio/bin&apos;export ANDROIDexport PATH=$ANDROID:$PATHFFMPEG=&apos;/home/willkernel/Downloads/ffmpeg-2.6.9&apos;export FFMPEGexport PATH=$FFMPEG:$PATH 常用命令50 Most Frequently Used UNIX / Linux Commands (With Examples)50个最常用的Unix/Linux命令 其他 install lantern in Ubuntu and launch lanternsudo dpkg -i lantern *.deb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
</search>
