<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Notes(Data Binding)]]></title>
    <url>%2F2018%2F03%2F16%2FAndroid-Notes-Data-Binding%2F</url>
    <content type="text"><![CDATA[Data Binding Library build environment 123456android&#123;... dataBinding &#123; enabled = true &#125;&#125; Data Binding Compiler V2 12android.databinding.enableV2=true向后不兼容 Data Binding 布局文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;import type=&quot;java.util.List&quot; /&gt; &lt;import type=&quot;android.view.View&quot; /&gt; &lt;import type=&quot;com.willkernel.www.databindingdemo.User&quot; /&gt; &lt;import type=&quot;com.willkernel.www.databindingdemo.DoSomething&quot; /&gt; &lt;!--&lt;variable--&gt; &lt;!--name=&quot;view&quot;--&gt; &lt;!--type=&quot;View&quot; /&gt;--&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot; /&gt; &lt;variable name=&quot;userClick&quot; type=&quot;com.willkernel.www.databindingdemo.MainActivity.UserClick&quot; /&gt; &lt;variable name=&quot;ds&quot; type=&quot;DoSomething&quot; /&gt; &lt;/data&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;userClick::onUserClick&#125;&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;() -&gt; userClick.onUserClick(user)&#125;&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt; &lt;!--android:onClick=&quot;@&#123;userClick::onUserClick&#125;&quot;--&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;(v) -&gt; userClick.onUserClick(v,user)&#125;&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt; &lt;CheckBox android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onCheckedChanged=&quot;@&#123;(cb,isChecked) -&gt; userClick.onCheckedChanged(user,isChecked)&#125;&quot; android:text=&quot;@&#123;user.lastName&#125;&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onLongClick=&quot;@&#123;(v)-&gt;userClick.onLongClick(v,user)&#125;&quot; android:text=&quot;@&#123;user.lastName&#125;&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE:View.INVISIBLE&#125;&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;DoSomething.capital(user.firstName)&#125;&quot; /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/layout&gt; data标签下的variable描述将会在布局中使用的属性 1&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; 使用”@{}” 语法获取属性 123&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt; 三种情况databinding都可以获取属性 123456789101. public final String firstName;2. private final String firstName; public String getFirstName() &#123; return this.firstName; &#125;3. private final String firstName; public String firstName() &#123; return this.firstName; &#125; 数据绑定,默认基于布局文件名称生成绑定类，将其转换为Pascal实例并添加Binding后缀，例如布局文件activity_main.xml,生成的类为MainActivityBinding,持有布局所有属性的绑定方法 12345678910111213141516 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); User user = new User(); user.firstName = &quot;firstName&quot;; user.lastName = &quot;lastName&quot;; user.isAdult = true; binding.setUser(user); binding.setUserClick(new UserClick());&#125;也可以这样获取ViewActivityMainBinding binding =ActivityMainBinding.inflate(getLayoutInflater());MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false); ListView,RecyclerView适配器中绑定 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);//orListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); 如果通过其他方式填充的布局，需要调用bind方法 1MyLayoutBinding binding =MyLayoutBinding.bind(viewRoot); 另外的方式 123ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId); 布局中的views将没有设置id的会生成private final ID，设置id的会生成public final ID ，比findViewById速度更快 生成的方法 variable 12345678910111213&lt;data&gt; &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt; &lt;variable name=&quot;note&quot; type=&quot;String&quot;/&gt;&lt;/data&gt;public abstract com.example.User getUser();public abstract void setUser(com.example.User user);public abstract Drawable getImage();public abstract void setImage(Drawable image);public abstract String getNote();public abstract void setNote(String note); ViewStubs因为在显示后会从view层级中消失，所以view的binding对象也会被回收 12345678910111213@NonNullpublic final android.databinding.ViewStubProxy viewStub;binding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; Log.e(TAG, &quot;inflated=&quot; + inflated + &quot; stub=&quot; + stub); &#125;&#125;);if (!binding.viewStub.isInflated()) &#123; binding.viewStub.getViewStub().inflate();&#125; 事件处理两种方式 方法引用 1234567891011121314151617181920 public class MyHandlers &#123; public void onClickFriend(View view) &#123; ... &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;handlers&quot; type=&quot;com.example.MyHandlers&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.firstName&#125;&quot; android:onClick=&quot;@&#123;handlers::onClickFriend&#125;&quot;/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听绑定 123456789101112131415 public class Presenter &#123; public void onSaveClick(Task task)&#123;&#125;&#125;绑定点击事件到类 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt; &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; “@{() -&gt; presenter.onSaveClick(task)}”可以忽略所有参数，也可以写上参数 1android:onClick=&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot; 如果类中有参数View 12345 public class Presenter &#123; public void onSaveClick(View view, Task task)&#123;&#125;&#125;绑定点击事件android:onClick=&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot; 可以使用lambda表达式添加更多参数 123456 public class Presenter &#123; public void onCompletedChanged(Task task, boolean completed)&#123;&#125;&#125; &lt;CheckBox android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onCheckedChanged=&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot; /&gt; 如果类中的方法返回值不是void，点击事件的绑定表达式返回值应该和方法一样,如果返回值因为空对象不能判断，会返回对象的默认值 1234 public class Presenter &#123; public boolean onLongClick(View view, Task task)&#123;&#125;&#125; android:onLongClick=&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot; 可以使用void作为三元运算符的标记 1android:onClick=&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot; 避免复杂监听，有些默认的点击事件处理的实现 12345SearchView setOnSearchClickListener(View.OnClickListener) android:onSearchClickZoomControls setOnZoomInClickListener(View.OnClickListener) android:onZoomOut ZoomControls setOnZoomOutClickListener(View.OnClickListener) android:onZoomOut Layout Details data元素标签下，可以导入多个类 123&lt;data&gt; &lt;import type=&quot;android.view.View&quot;&gt;&lt;/data&gt; binding表达式中可以使用View 12345&lt;TextView android:text=&quot;@&#123;user.lastName&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt; 导入类名冲突可以使用别名 123&lt;import type=&quot;android.view.View&quot;/&gt;&lt;import type=&quot;com.example.real.estate.View&quot; alias=&quot;Vista&quot;/&gt; 导入类可以设置变量 123456&lt;data&gt; &lt;import type=&quot;com.example.User&quot;/&gt; &lt;import type=&quot;java.util.List&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt; &lt;variable name=&quot;userList&quot; type=&quot;List&amp;lt;User&amp;gt;&quot;/&gt;&lt;/data&gt; 引用静态变量和方法 123456789&lt;data&gt; &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;&lt;/data&gt;…&lt;TextView android:text=&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 如果variable实现了android.databinding.Observable或者observable collection，应该在反映在type中，当没有实现上述接口时，变量将不会被观察Observer 当横竖屏不同布局时，变量会整合，不同布局不要有命名冲突 binding 类的主要方法,其中context是来自rootview的contextbinding.getRoot().getContext() 重命名Binding对象 12&lt;data class=&quot;MainAty&quot;&gt; MainAty binding = DataBindingUtil.setContentView(this, R.layout.activity_main); 设置Binding包名 1234当前应用包名 &lt;data class=&quot;.MainAty&quot;&gt; 重新设置完整的包名 &lt;data class=&quot;com.main.MainAty&quot;&gt; include 绑定变量 12&lt;include layout=&quot;@layout/contact&quot; bind:user=&quot;@&#123;user&#125;&quot;/&gt; include布局元素不能作为merge的子元素 表达式语法 1234exapmples:android:text=&quot;@&#123;String.valueOf(index + 1)&#125;&quot;android:visibility=&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;android:transitionName=&apos;@&#123;&quot;image_&quot; + id&#125;&apos; 非空判断?? 123android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;等价于android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot; 规避空指针异常，当variable为空时，属性值会显示相应的默认值 集合 123456789101112131415161718192021222324\&lt;import type=&quot;java.util.List&quot; /&gt; &lt;import type=&quot;android.util.SparseArray&quot; /&gt; &lt;import type=&quot;java.util.Map&quot; /&gt; &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot; /&gt; &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot; /&gt; &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String,String&amp;gt;&quot; /&gt; &lt;variable name=&quot;index&quot; type=&quot;int&quot; /&gt; &lt;variable name=&quot;key&quot; type=&quot;String&quot; /&gt;android:text=&quot;@&#123;list[index]&#125;&quot;android:text=&quot;@&#123;sparse[index]&#125;&quot;android:text=&quot;@&#123;map[key]&#125;&quot; 字符串引用 123android:text=&apos;@&#123;map[&quot;firstName&quot;]&#125;&apos;android:text=&quot;@&#123;map[`firstName`&#125;&quot;android:text=&quot;@&#123;map[&apos;firstName&apos;]&#125;&quot; 表达式中的资源引用 数据对象 数据自动更新通知机制 123Observable objectsObservable fieldsObservable collections Observable Objects 继承自BaseObservable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public class BaseObservable implements Observable &#123; private transient PropertyChangeRegistry mCallbacks; public BaseObservable() &#123; &#125; @Override public void addOnPropertyChangedCallback(OnPropertyChangedCallback callback) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; mCallbacks = new PropertyChangeRegistry(); &#125; &#125; mCallbacks.add(callback); &#125; @Override public void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; return; &#125; &#125; mCallbacks.remove(callback); &#125; /** * Notifies listeners that all properties of this instance have changed. */ public void notifyChange() &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; return; &#125; &#125; mCallbacks.notifyCallbacks(this, 0, null); &#125; /** * Notifies listeners that a specific property has changed. The getter for the property * that changes should be marked with &#123;@link Bindable&#125; to generate a field in * &lt;code&gt;BR&lt;/code&gt; to be used as &lt;code&gt;fieldId&lt;/code&gt;. * * @param fieldId The generated BR id for the Bindable field. */ public void notifyPropertyChanged(int fieldId) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; return; &#125; &#125; mCallbacks.notifyCallbacks(this, fieldId, null); &#125;&#125; 在getter()添加@Bindable注解,在setter()中添加notifyPropertyChanged(BR.lastName); 12345678910111213141516171819202122232425262728293031323334 private static class User extends BaseObservable &#123; private String firstName; private String lastName; @Bindable public String getFirstName() &#123; return this.firstName; &#125; @Bindable public String getLastName() &#123; return this.lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125;上面user例子，实现自动刷新UI@Bindablepublic boolean isAdult() &#123; return isAdult;&#125;public void setAdult(boolean adult) &#123; isAdult = adult; notifyPropertyChanged(BR.adult); &#125;user.isAdult = !user.isAdult;binding.setUser(user); Observable Fields 不需要写setter() getter(),需要初始化new Observable***() 1public class ObservableParcelable&lt;T extends Parcelable&gt; extends ObservableField&lt;T&gt; implements Parcelable, Serializable 实例 12345678910 private static class User &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125;user.firstName.set(&quot;Google&quot;);int age = user.age.get(); Observable Collections ObservableArrayMap 1234567ObservableArrayMap&lt;String, Object&gt; observableMap = new ObservableArrayMap&lt;&gt;();observableMap.put(&quot;firstName&quot;, &quot;Google&quot;);observableMap.put(&quot;lastName&quot;, &quot;Inc.&quot;);observableMap.put(&quot;age&quot;, 17);binding.setObservableMap(observableMap);android:text=&apos;@&#123;String.valueOf(observableMap[&quot;age&quot;])&#125;&apos; ObservableArrayList 1234567ObservableArrayList&lt;Object&gt; list = new ObservableArrayList&lt;&gt;();list.add(&quot;Google&quot;);list.add(&quot;Inc.&quot;);list.add(17);binding.setObservableList(list); android:text=&quot;@&#123;String.valueOf(observableList[index])&#125;&quot; Advanced Binding 高级绑定 动态变量RecyclerView.Adapter中在onBindViewHolder(VH, int)设置值,其中BindingHolder有一个getBinding()方法 12345public void onBindViewHolder(BindingHolder holder, int position) &#123; final T item = mItems.get(position); holder.getBinding().setVariable(BR.item, item); holder.getBinding().executePendingBindings();&#125; 立即绑定当变量或观察者发生变化时，绑定会在下一帧绘制时发生改变，然而有时候需要强制重新绑定 1android.databinding.ViewDataBinding.executePendingBindings() 后台线程 可以在后台线程改变数据model，只要不是集合，数据绑定本地化每个变量，规避线程并发问题 属性设置 重命名setters]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Dagger)]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid-Notes-Dagger%2F</url>
    <content type="text"><![CDATA[Dagger依赖注入（Dependency Injection），简称DI，又叫控制反转（Inversion of Control），简称IOC当一个类的实例需要另一个类的实例，在传统的设计中，通常由调用者来创建被调用者的实例，然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由IOC容器来完成，然后注入到调用者。因此也被称为依赖注入 API 12345678910111213141516171819202122232425262728293031public @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;; @Target(TYPE) @Documented @interface Builder &#123;&#125;&#125;public @interface Subcomponent &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; @Target(TYPE) @Documented @interface Builder &#123;&#125;&#125;public @interface Module &#123; Class&lt;?&gt;[] includes() default &#123;&#125;; @Beta Class&lt;?&gt;[] subcomponents() default &#123;&#125;;&#125;public @interface Provides &#123;&#125;public @interface MapKey &#123; boolean unwrapValue() default true;&#125;public interface Lazy&lt;T&gt; &#123; T get();&#125; @Inject声明依赖注入构造方法，自动请求参数并调用构造方法 12345678910 class Thermosiphon implements Pump &#123; private final Heater heater; @Inject Thermosiphon(Heater heater) &#123; this.heater = heater; &#125; ...&#125; @Inject fields 实例化成员变量如果你的类有@Inject成员变量，但是没有@Inject构造方法，Dagger会注入这些变量，但是不会创建新的对象。所有添加@Inject无参的构造函数让Dagger也可以创建对象，也可以@Inject method(),当然Field，Constructor是首选。 12345 class CoffeeMaker &#123; @Inject Heater heater; @Inject Pump pump; ...&#125; @Inject不足 1234类中只能包含一个@Inject constructor接口，抽象类是没有构造方法的第三方库提供的类，它们的构造方法不能被注解有些类需要灵活选择初始化的配置，而不是使用一个单一的构造方法 @Provides 可以满足上面的依赖性，但是必须属于一个Module,有一个惯例方法前缀加provide，类后缀加Module 12345678910 @Moduleclass DripCoffeeModule &#123; @Provides static Heater provideHeater() &#123; return new ElectricHeater(); &#125; @Provides static Pump providePump(Thermosiphon pump) &#123; return pump; &#125;&#125; @Component 在接口中，传入Module，完成接口和类的注入，将CoffeeShop 通过DripCoffeeModule注入到MainActivity中@Component中使用modules，表明该Component在哪些注入的Module中查找依赖@Component中使用dependencie，表明该Component在哪些注入的Component中查找依赖添加注入方法，一般使用inject可以声明方法，提供注入的实例 123456789101112131415161718 @Component(modules = DripCoffeeModule.class)interface CoffeeShop &#123; CoffeeMaker maker();&#125;CoffeeShop coffeeShop = DaggerCoffeeShop.builder() .dripCoffeeModule(new DripCoffeeModule()) .build();//如果@Component不是在类的上方，生成组件时需要添加下划线class Foo &#123; static class Bar &#123; @Component interface BazComponent &#123;&#125; &#125;&#125;DaggerFoo_Bar_BazComponent 如果所有的依赖关系都可以在不需要实例对象的情况下创建，那么可以使用builder(),也可以使用crete()创建实例，对于所有的@Provides方法都是静态的Module，可以不需要考虑builder 1CoffeeShop coffeeShop = DaggerCoffeeShop.create(); 针对在MainActivity中的依赖注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 public class Car &#123; @Inject public Car() &#123; &#125; public String show() &#123; return String.valueOf(1); &#125;&#125; @Componentpublic interface MainActivityComponent &#123; void inject(MainActivity activity);&#125;public class MainActivity extends AppCompatActivity &#123; @Inject Car car; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 先编译一次crtl+F9 DaggerMainActivityComponent.create().inject(this); String show = car.show(); Toast.makeText(MainActivity.this, show, Toast.LENGTH_SHORT).show(); &#125;&#125; //Water 抽象类，@Inject无法提供实例 @Inject public Car(Water water) &#123; &#125; //清除子类@Inject //@Inject public HotWater()&#123; &#125; // @Inject public CoolWater()&#123; &#125;/** *@Module标记在类上面 *@Provodes标记在方法上 *表示可以通过这个方法获取依赖 */@Modulepublic class WaterModule &#123; @Provides Water provideWater()&#123; return new HotWater(); &#125;&#125; /** * 在Component中指定Module */@Component(modules = WaterModule.class)public interface MainActivityComponent &#123; void inject(MainActivity mainActivity);&#125; @Module需要和@Provide是需要一起使用的时候才具有作用的，并且@Component也需要指定了Module@Module是告诉Component，可以从这里获取依赖对象。Component就会去找被@Provide标注的方法，相当于构造器的@Inject可以提供依赖,@Component可以指定多个@Module的 Component可以包含多个Module或者Component，这样Component获取依赖时候会自动从多个Module中查找获取，但是，Module间不能有重复方法 123456789101112131415161718在Component中的modules属性中注入多个Module@Component(modules=&#123;ModuleA.class,ModuleB.class,...&#125;)public interface FruitComponent&#123; ...&#125;在Component中的dependencies属性中注入多个依赖的Component@Component(dependencies=&#123;ComponentA.class,ComponentB.class,...&#125;) public interface FruitComponent&#123; ...&#125;在Module中注入多个Module@Module(includes=&#123;ModuleA.class,ModuleB.class,...&#125;)public class FruitModule&#123; ...&#125; 注入的Module，不管是属于Component本身还是注入的Module的依赖，如果其构造函数为有参构造函数，必须进行初始化 123DaggerFruitComponent.builder() .orangeModule(new OrangeModule(new OrangeBean(&quot;贡菊&quot;, 6.88, &quot;江西南昌&quot;))) .build(); 依赖规则步骤1：查找Module中是否存在创建该类的方法。 步骤2：若存在创建类方法，查看该方法是否存在参数步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入结束 步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入结束 在Component中，可以声明方法，比如makeApple()，直接提供注入对象实例。DaggerFruitComponent针对每一个@Provides方法创建Provider\&lt;T>实例。在调用makeApple()方法时，实际上是调用的相应Provider的get()方法，获取相应的实例 123public AppleBean makeApple() &#123; return provideAppleProvider.get();&#125; 依赖对象的注入源应该是有两个，一是Module中的@Provides方法，二是使用@Inject注解的构造函数 单例@Singleton,可以做文档注释，提醒是线程安全 123 @Provides @Singleton static Heater provideHeater() &#123; return new ElectricHeater();&#125; @Qualifier是限定符，而@Named则是基于String的限定符,容易写错，推荐@Qualifier 自定义注解 123456789101112 @Provides @CoolQualifier// @Named(&quot;Cool&quot;) Water provideCoolWater() &#123; return new CoolWater(); &#125;// 另外的一种方式，这里Water是抽象类，可以考虑其他对象Light灯光// @Provides// Water providePot(@CoolQualifier Water w) &#123;// return new Water(w);// &#125; @Component与@SubComponent Car 12345@Injectpublic Car(Water water) &#123; this.water = water; oil = new Oil();&#125; WaterComponent 123456789101112 /** * @Module标记在类上面 * @Provodes标记在方法上 表示可以通过这个方法获取依赖 */@Component(modules = WaterModule.class)public interface WaterComponent &#123; @HotQualifier Water getHotWater(); @CoolQualifier Water getCoolWater();&#125; CarModule 1234567 @Modulepublic class CarModule &#123; @Provides Car provideCar(@CoolQualifier Water water)&#123; return new Car(water); &#125;&#125; CarComponent 12345678 /** * @Module标记在类上面 * @Provodes标记在方法上 表示可以通过这个方法获取依赖 */@Component(modules = CarModule.class, dependencies = WaterComponent.class)public interface CarComponent &#123; Car getCar();&#125; MainActivityComponent 1234 @Component(dependencies = CarComponent.class)public interface MainActivityComponent &#123; void inject(MainActivity mainActivity);&#125; MainActivity 1234567DaggerMainActivityComponent.builder() .carComponent(DaggerCarComponent.builder() .waterComponent(DaggerWaterComponent.create()) .build()) .build() .inject(this);Log.e(TAG, car.show()); CarComponent依赖WaterComponent，将WaterComponent的引用传递给CarComponent，这样CarComponent就可以使用WaterComponent中的方法。在DaggerCarComponent中的getCar()方法，waterComponent.getCoolWater()获取Water 通过@SubComponent实现 1234567891011121314@Component(modules = WaterModule.class)public interface WaterComponent &#123; CarComponent plus(CarModule carModule);&#125;@Subcomponent(modules = CarModule.class)public interface CarComponent&#123; MainActivityComponent plus();&#125;@Subcomponentpublic interface MainActivityComponent &#123; void inject(MainActivity mainActivity);&#125; Component和SubComponent区别 1234Component dependencies 能单独使用，而Subcomponent必须由Component调用方法获取。Component dependencies 可以很清楚的得知他依赖哪个Component， 而Subcomponent不确定使用上的区别，Subcomponent就像这样DaggerAppComponent.plus(new SharePreferenceModule());使用Dependence可能是这样DaggerAppComponent.sharePreferenceComponent(SharePreferenceComponent.create()) @Scope和@Singleton@Scope管理依赖的生命周期，@Scope对某类注解后，其作用的核心应该是注入器的控制，注入实例时，控制注入器调用缓存的实例还是重新实例,自定义注解，而@Singleton是@Scope默认实现如果有类注入实例的类被@Scope注解，那么其Component必须被相同的Scope注解 1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 依赖实例的注入来源是@Provides方法时，@Provides方法必须被@Scope注解；如果依赖实例的注入来源是@Inject注解的构造函数时，实例类必须被@Scope注解。这样@Scope注解才会有效。也就是说，@Scope实际上是对注入器的控制 Scope控制的实例的注入器是当前Component之内的实例注入器，而不会影响其他的Component中的实例注入器 更好的管理Component之间的组织方式，用自定义的Scope注解标注这些Component，检查有依赖关系或包含关系的Component，若发现Component没有用自定义Scope注解标注，则会报错 编译器会检查 Component管理的Modules，标注Component的自定义Scope注解与Modules中的标注创建类实例方法的注解不一样会报错 单例实例 1234567891011121314151617181920@InjectCar car1;//可以注入多个Car,但是重新创建了一个依赖@InjectCar car2;//使用单例，@Singleton@Modulepublic class CarModule &#123; @Provides @Singleton Car provideCar(@CoolQualifier Water water)&#123; return new Car(water); &#125;&#125;@Singleton@Component(modules = CarModule.class, dependencies = WaterComponent.class)public interface CarComponent &#123; Car getCar();&#125; 编译报错 12Error:(16, 1) 错误: com.willkernel.www.daggerdemo.component.MainActivityComponent (unscoped) cannot depend on scoped components:@Singleton com.willkernel.www.daggerdemo.component.CarComponent 在Component中指定ModuleMainActivityComponent依赖CarComponent而dagger2规定使用单例的Component,子Component也必须标注@Scope但是不能标注@Singleton,不允许，单例依赖单例不符合设计原则需要自定义一个@Scope，例如ActivityScope@Singleton 需要在@Provide和@Component,还有MainActivityComponent中使用@Scope才能够顺利编译，保持局部单例 可以注入多个Car,但是重新创建了一个依赖，使用单例后两个地址一样， 但是在其他Activity中，地址又不一样，属于局部单例，在其他Activity重新 创建了注入器Component,所以Car对象的地址改变了 Dagger正确使用单例 依赖在Component中是单例的（供该依赖的provide方法和对应的Component类使用同一个Scope注解） 对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象（在Application中创建该Component） App 123456789101112131415public class App extends Application &#123; private CarComponent carComponent; @Override public void onCreate() &#123; super.onCreate(); carComponent = DaggerCarComponent.builder() .waterComponent(DaggerWaterComponent.create()) .build(); &#125; public CarComponent getCarComponent() &#123; return carComponent; &#125;&#125; SecondActivity 12345678@InjectCar car3;DaggerSecondActivityComponent.builder() .carComponent(((App) getApplication()).getCarComponent()) .build() .inject(this); Log.e(TAG, &quot;car3=&quot; + car3.hashCode()); 也可以通过ApplciationScope使用单例 12345678910111213141516171819202122232425@Scope@Retention(RUNTIME)public @interface ApplicationScope &#123;&#125;public class App extends Application&#123; @Inject Car car; @Override public void onCreate() &#123; super.onCreate(); DaggerAppComponent.builder().carComponent(DaggerCarComponent.builder() .waterComponent(DaggerWaterComponent.create()).build()) .build() .inject(this); &#125; public Car getCar() &#123; return car; &#125; 在SecondeActivity中引用car6=((App)getApplication()).getCar(); Log.e(TAG, &quot;car6=&quot; + car6.hashCode()); MapKey 1234567891011121314151617181920212223242526272829@Component(modules = MapKeyModule.class)public interface MapComponent &#123; Map&lt;String, String&gt; mapkey();&#125;@Modulepublic class MapKeyModule &#123; @Provides @IntoMap @TestKey(&quot;foo&quot;) String provideFooKey() &#123; return &quot;foo value&quot;; &#125; @Provides @IntoMap @TestKey(&quot;bar&quot;) String provideBarKey() &#123; return &quot;bar value&quot;; &#125;&#125;@MapKey(unwrapValue = true)public @interface TestKey &#123; String value();&#125;Map&lt;String, String&gt; map = DaggerMapComponent.create().mapkey(); Log.e(TAG, &quot;map &quot; + map.toString()); Lazy通过Lazy提供的实例，在@Inject的时候并不初始化，而是使用的时候，主动调用其get方法来获取实例，并且会缓存该对象 12345@InjectLazy&lt;Car&gt; carLazy;Car carL = carLazy.get();Log.e(TAG, &quot;carL &quot; + carL.show()); Provider有时您需要注入多个实例列表，而不是注入单个值。可以注入一个Provider ，而不只是T。当Provider 每次调用get()方法时，都会执行绑定逻辑并创建一个新的实例，地址不一样，但@Scope注解的类地址是一样的 1234567891011121314@CoffeeScopepublic class CoffeeBean &#123; @Inject public CoffeeBean() &#123; Log.d(&quot;test&quot;, &quot;Coffee()&quot;); &#125;&#125; @Inject Provider&lt;CoffeeBean&gt; mCoffeeBeanProvider CoffeeBean beanA = mCoffeeBeanProvider.get(); CoffeeBean beanB = mCoffeeBeanProvider.get(); 多个元素绑定并注入到Set 将单个元素注入到Set 1234567@Moduleclass MyModuleA &#123; @Provides @IntoSet static String provideOneString(DepA depA, DepB depB) &#123; return &quot;ABC&quot;; &#125;&#125; Set 注入到Set 1234567 @Moduleclass MyModuleB &#123; @Provides @ElementsIntoSet static Set&lt;String&gt; provideSomeStrings(DepA depA, DepB depB) &#123; return new HashSet&lt;String&gt;(Arrays.asList(&quot;DEF&quot;, &quot;GHI&quot;)); &#125;&#125; 在Component中，表明注入到Set的实例的提供Module,声明setApple()方法，用来提供集合Set 1234567891011121314151617 class Bar &#123; @Inject Bar(Set&lt;String&gt; strings) &#123; assert strings.contains(&quot;ABC&quot;); assert strings.contains(&quot;DEF&quot;); assert strings.contains(&quot;GHI&quot;); &#125;&#125; 或者 @Component(modules = &#123;MyModuleA.class, MyModuleB.class&#125;)interface MyComponent &#123; Set&lt;String&gt; strings();&#125;@Test void testMyComponent() &#123; MyComponent myComponent = DaggerMyComponent.create(); assertThat(myComponent.strings()).containsExactly(&quot;ABC&quot;, &quot;DEF&quot;, &quot;GHI&quot;);&#125; 也可以通过Provider&lt;Set&gt; or Lazy&lt;Set&gt;来依赖注入实例，但是不能通过Set&lt;Provider&gt;&gt; 增加限定符@Qualifier 1234567891011121314@Moduleclass MyModuleC &#123; @Provides @IntoSet @MyQualifier static Foo provideOneFoo(DepA depA, DepB depB) &#123; return new Foo(depA, depB); &#125;&#125;@Moduleclass MyModuleD &#123; @Provides static FooSetUser provideFooSetUser(@MyQualifier Set&lt;Foo&gt; foos) &#123; ... &#125;&#125; 多个元素绑定并注入到Map在Module中的@Provides方法使用@IntoMap，同时指定该元素的Key(例如@StringKey(“foo”)，@ClassKey(Thing.class),@IntKey(12),@LongKey(100L))，没有这个key时，返回null 123456789101112131415161718192021222324252627 @Moduleclass MyModule &#123; @Provides @IntoMap @StringKey(&quot;foo&quot;) static Long provideFooValue() &#123; return 100L; &#125; @Provides @IntoMap @ClassKey(Thing.class) static String provideThingValue() &#123; return &quot;value for Thing&quot;; &#125;&#125;@Component(modules = MyModule.class)interface MyComponent &#123; Map&lt;String, Long&gt; longsByString(); Map&lt;Class&lt;?&gt;, String&gt; stringsByClass();&#125;@Test void testMyComponent() &#123; MyComponent myComponent = DaggerMyComponent.create(); assertThat(myComponent.longsByString().get(&quot;foo&quot;)).isEqualTo(100L); assertThat(myComponent.stringsByClass().get(Thing.class)) .isEqualTo(&quot;value for Thing&quot;);&#125; 如果key是枚举或其他特定的类，使用@MapKey注解,自定义Key 自定义枚举类型，数据包装类key如果不满足指定的返回类型，那么编译时会报错：基本数据类型StringClass(参数化类，? extends Number)枚举类型注解类型以上数据类型的数组 12345678910111213enum MyEnum &#123; ABC, DEF;&#125; @MapKey@interface MyEnumKey &#123; MyEnum value();&#125;@MapKey@interface MyNumberClassKey &#123; Class&lt;? extends Number&gt; value();&#125; 在Module中的@Prvoides使用@IntoMap,并指明key 1234567891011121314 @Moduleclass MyModule &#123; @Provides @IntoMap @MyEnumKey(MyEnum.ABC) static String provideABCValue() &#123; return &quot;value for ABC&quot;; &#125; @Provides @IntoMap @MyNumberClassKey(BigDecimal.class) static String provideBigDecimalValue() &#123; return &quot;value for BigDecimal&quot;; &#125;&#125; 注入器Component 123456789101112 @Component(modules = MyModule.class)interface MyComponent &#123; Map&lt;MyEnum, String&gt; myEnumStringMap(); Map&lt;Class&lt;? extends Number&gt;, String&gt; stringsByNumberClass();&#125;@Test void testMyComponent() &#123; MyComponent myComponent = DaggerMyComponent.create(); assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo(&quot;value for ABC&quot;); assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class)) .isEqualTo(&quot;value for BigDecimal&quot;);&#125; 组合的MapKey，设置unwrapValue的值为false，这样key值也可以是数组成员，key不唯一指定，可以有多个不同类型的key 1234567891011121314151617181920 @MapKey(unwrapValue = false)@interface MyKey &#123; String name(); Class&lt;?&gt; implementingClass(); int[] thresholds();&#125;@Moduleclass MyModule &#123; @Provides @IntoMap @MyKey(name = &quot;abc&quot;, implementingClass = Abc.class, thresholds = &#123;1, 5, 10&#125;) static String provideAbc1510Value() &#123; return &quot;foo&quot;; &#125;&#125;@Component(modules = MyModule.class)interface MyComponent &#123; Map&lt;MyKey, String&gt; myKeyStringMap();&#125; 使用MapKey,需要生成Mykey的静态方法，就需要使用@AutoAnnotation 123456789101112131415 apt 被annotationProcessor替代 apply plugin: &apos;com.neenbedankt.android-apt&apos; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; annotationProcessor &quot;com.google.auto.value:auto-value-annotations:1.5&quot; implementation &quot;com.google.auto.value:auto-value:1.5&quot; @AutoAnnotationstatic MyKey createMyKey(String name, Class&lt;?&gt; implementingClass, int[] thresholds) &#123; return new AutoAnnotation_MainActivity_createMyKey(name, implementingClass, thresholds); &#125; MyKeyComponent myKeyComponent = DaggerMyKeyComponent.create(); Log.e(TAG, &quot;myKeyComponent &quot;+myKeyComponent.myKeyStringMap() .get(createMyKey(&quot;abc&quot;, BigDecimal.class, new int[]&#123;1, 2, 4&#125;))); Mapkey的key在编译期间未知，就不能创建Mapkey的绑定，不过可以先设置绑定Set，再转换为Map绑定 12345678910111213141516171819202122232425262728 @Moduleclass MyModule &#123; @Provides @IntoSet static Map.Entry&lt;Foo, Bar&gt; entryOne(...) &#123; Foo key = ...; Bar value = ...; return new SimpleImmutableEntry(key, value); &#125; @Provides @IntoSet static Map.Entry&lt;Foo, Bar&gt; entryTwo(...) &#123; Foo key = ...; Bar value = ...; return new SimpleImmutableEntry(key, value); &#125;&#125;@Moduleclass MyMapModule &#123; @Provides static Map&lt;Foo, Bar&gt; fooBarMap(Set&lt;Map.Entry&lt;Foo, Bar&gt;&gt; entries) &#123; Map&lt;Foo, Bar&gt; fooBarMap = new LinkedHashMap&lt;&gt;(entries.size()); for (Map.Entry&lt;Foo, Bar&gt; entry : entries) &#123; fooBarMap.put(entry.getKey(), entry.getValue()); &#125; return fooBarMap; &#125;&#125; Dagger并不会自动注入Map\&lt;Foo，Provider\&lt;Bar>>,也就意味着不会提供一个含有Provider值得Map。如果想要获取一个含有Provider的Map，需要在Map.Entry对象中包含Provider值，那么所获取的Map也就含有Provider 123456789101112131415161718@Moduleclass MyModule &#123; @Provides @IntoSet static Map.Entry&lt;Foo, Provider&lt;Bar&gt;&gt; entry( Provider&lt;BarSubclass&gt; barSubclassProvider) &#123; Foo key = ...; return new SimpleImmutableEntry(key, barSubclassProvider); &#125;&#125;@Moduleclass MyProviderMapModule &#123; @Provides static Map&lt;Foo, Provider&lt;Bar&gt;&gt; fooBarProviderMap( Set&lt;Map.Entry&lt;Foo, Provider&lt;Bar&gt;&gt;&gt; entries) &#123; return ...; &#125;&#125; 声明多重绑定@Multibinds-annotated,也可以使用@IntoSet,@IntoMap,@ElementsIntoSet,但是必须有一个 1234567@Moduleabstract class MyModule &#123; @Multibinds abstract Set&lt;Foo&gt; aSet(); @Multibinds @MyQualifier abstract Set&lt;Foo&gt; aQualifiedSet(); @Multibinds abstract Map&lt;String, Foo&gt; aMap(); @Multibinds @MyQualifier abstract Map&lt;String, Foo&gt; aQualifiedMap();&#125; Set或Map多重绑定可以声明任意次数而不会发生错误。Dagger从不实现或调用任何@Multibinds方法添加返回空集合的@ElementsIntoSet方法 1234567@Moduleclass MyEmptySetModule &#123; @Provides @ElementsIntoSet static Set&lt;Foo&gt; primeEmptyFooSet() &#123; return Collections.emptySet(); &#125;&#125; 添加子组件方式 @Component的dependencies属性依赖父组件 1234 @Component(modules = OrangeModule.class, dependencies = FruitComponent.class)public interface OrangeComponent &#123; ***&#125; @Module的Subcomponents添加子组件 12345 @Module(subcomponents = AppleSubcomponent.class)public class FruitModule &#123; ***&#125; @SubComponent声明子组件，需要提供@Subcomponent.Builder接口的Builder,build()来构建子组件 12345678910@Subcomponent(modules = RequestModule.class)interface RequestComponent &#123; RequestHandler requestHandler(); @Subcomponent.Builder interface Builder &#123; Builder requestModule(RequestModule module); RequestComponent build(); &#125;&#125; 添加子组件到父组件，添加子组件类到父组件的@Module的subcomponents属性,然后父组件调用子组件的builder方法 12@Module(subcomponents = RequestComponent.class)class ServerModule &#123;&#125; 父组件的注入器 123456789101112131415161718192021@Singleton@Component(modules = ServerModule.class)interface ServerComponent &#123; RequestRouter requestRouter();&#125;子组件实例注入@Singletonclass RequestRouter &#123; @Inject RequestRouter( Provider&lt;RequestComponent.Builder&gt; requestComponentProvider) &#123;&#125; void dataReceived(Data data) &#123; RequestComponent requestComponent = requestComponentProvider.get() .data(data) .build(); requestComponent.requestHandler() .writeResponse(200, &quot;hello, world&quot;); &#125;&#125; 子组件和作用域，如果没有作用域的绑定，每次注入都会重新创建独立的对象，但是如果有作用域绑定的对象，在作用域生命周期中绑定的对象实例是同一个 子组件和父组件的作用域不能相同，比父组件的生命周期短，两个子组件有不同的作用域实例，即使他们的作用域注解相同 12345678910111213141516@Singleton @Componentinterface RootComponent &#123; SessionComponent.Builder sessionComponent();&#125;@SessionScope @Subcomponentinterface SessionComponent &#123; FooRequestComponent.Builder fooRequestComponent(); BarRequestComponent.Builder barRequestComponent();&#125;@RequestScope @Subcomponentinterface FooRequestComponent &#123;...&#125;@RequestScope @Subcomponentinterface BarRequestComponent &#123;...&#125; 封装子组件在不同Service,不同界面，共享某些绑定，但是这些绑定中也有不需要的绑定实例，这时就需要使用子组件，对绑定实例进行细分 应用ApplicationComponent,注入数据库实例 12345 @Singleton @Component(modules = DatabaseModule.class)interface ApplicationComponent &#123; Database database();&#125; 数据库模块，子组件为DatabaseComponent 12345678910111213 @Module(subcomponents = DatabaseComponent.class)class DatabaseModule &#123; @Provides @Singleton Database provideDatabase( @NumberOfCores int numberOfCores, DatabaseComponent.Builder databaseComponentBuilder) &#123; return databaseComponentBuilder .databaseImplModule(new DatabaseImplModule(numberOfCores / 2)) .build() .database(); &#125;&#125; 数据库实现类模块 123456 @Moduleclass DatabaseImplModule &#123; DatabaseImplModule(int concurrencyLevel) &#123;&#125; @Provides DatabaseConnectionPool provideDatabaseConnectionPool() &#123;&#125; @Provides DatabaseSchema provideDatabaseSchema() &#123;&#125;&#125; 子组件 1234 @Subcomponent(modules = DatabaseImplModule.class)interface DatabaseComponent &#123; @PrivateToDatabase Database database();&#125; 抽象工厂方法定义子组件 扩展多重绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Subcomponent(modules = DatabaseImplModule.class)interface DatabaseComponent &#123; @PrivateToDatabase Database database();&#125;@Moduleclass ParentModule &#123; @Provides @IntoMap @StringKey(&quot;one&quot;) static int one() &#123; return 1; &#125; @Provides @IntoMap @StringKey(&quot;two&quot;) static int two() &#123; return 2; &#125; @Provides @IntoSet static String a() &#123; return &quot;a&quot; &#125; @Provides @IntoSet static String b() &#123; return &quot;b&quot; &#125;&#125;@Subcomponent(modules = ChildModule.class)interface Child &#123; Map&lt;String, Integer&gt; map(); Set&lt;String&gt; set();&#125;@Moduleclass ChildModule &#123; @Provides @IntoMap @StringKey(&quot;three&quot;) static int three() &#123; return 3; &#125; @Provides @IntoMap @StringKey(&quot;four&quot;) static int four() &#123; return 4; &#125; @Provides @IntoSet static String c() &#123; return &quot;c&quot; &#125; @Provides @IntoSet static String d() &#123; return &quot;d&quot; &#125;&#125;Parent parent = DaggerParent.create();Child child = parent.child();assertThat(parent.map().keySet()).containsExactly(&quot;one&quot;, &quot;two&quot;);assertThat(child.map().keySet()).containsExactly(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);assertThat(parent.set()).containsExactly(&quot;a&quot;, &quot;b&quot;);assertThat(child.set()).containsExactly(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;); 模块Module作为工厂方法的参数会在编译时报错，重复模块Module在依赖注入获取对象时引用是运行时错误 123456789101112131415161718192021@Component(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentOne &#123; ComponentTwo componentTwo(RepeatedModule repeatedModule); // COMPILE ERROR! ComponentThree.Builder componentThreeBuilder();&#125;@Subcomponent(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentTwo &#123; ... &#125;@Subcomponent(modules = &#123;RepeatedModule.class, ...&#125;)interface ComponentThree &#123; @Subcomponent.Builder interface Builder &#123; Builder repeatedModule(RepeatedModule repeatedModule); ComponentThree build(); &#125;&#125;DaggerComponentOne.create().componentThreeBuilder() .repeatedModule(new RepeatedModule()) // UnsupportedOperationException! .build(); Dagger Android 引入Dagger 1234567// Dagger dependenciesannotationProcessor &quot;com.google.dagger:dagger-compiler:$rootProject.daggerVersion&quot;provided &apos;org.glassfish:javax.annotation:10.0-b28&apos;compile &quot;com.google.dagger:dagger:$rootProject.daggerVersion&quot;compile &quot;com.google.dagger:dagger-android:$rootProject.daggerVersion&quot;compile &quot;com.google.dagger:dagger-android-support:$rootProject.daggerVersion&quot;annotationProcessor &quot;com.google.dagger:dagger-android-processor:$rootProject.daggerVersion&quot; @Binds注解委托绑定模块的抽象方法，例如绑定Random到SecureRandom模块 1@Binds abstract Random bindRandom(SecureRandom secureRandom); 是@Provides的替代方法，更高效 @Binds method必须是抽象方法必须是一个可以转换为返回值类型的参数，参数是返回值类型的子类或实现类，将返回值类绑定到参数类,将参数暴露为返回值类型，不需要实例化参数对象可以有限定符@Qualified和作用域@Scoped1234@Documented@Retention(RUNTIME)@Target(METHOD)public @interface Binds &#123;&#125; @ContributesAndroidInjector注解的方法生成的返回值对应的AndroidInjector。该注入器是 dagger.Subcomponent的实现，而且是dagger.Module 的子Component用于注解返回具体的Android框架类型(例如:FooActivity、BarFragment、MyService等）的dagger.Module中的无参抽象方法 BindsInstance 标识组件或子组件的Builder方法，绑定对象到组件中的类 12345@Documented@Retention(RUNTIME)@Target(METHOD)@Betapublic @interface BindsInstance &#123;&#125; 注入实例由于DispatchingAndroidInjector在运行时由类查找相应的AndroidInjector.Factory，那么，在基类中，实现HasActivityInjector/HasFragmentInjector接口，在相应的声明周期(onCreate()或者onAttach())内调用AndroidInjection.inject()方法，注入相应的实例。所有每个子类都需要做的是绑定相应的@Subcomponent，从而没有必要在每个实例类中调用AndroidInjection.inject()方法。 12345678910111213141516@Betapublic abstract class DaggerActivity extends Activity implements HasFragmentInjector &#123; @Inject DispatchingAndroidInjector&lt;Fragment&gt; fragmentInjector; @Override protected void onCreate(Bundle savedInstanceState) &#123; AndroidInjection.inject(this); super.onCreate(savedInstanceState); &#125; @Override public AndroidInjector&lt;Fragment&gt; fragmentInjector() &#123; return fragmentInjector; &#125;&#125; 在dagger.android库中，有一些基本类型,对于Appliaction是DaggerApplication，只需重写applicationInjectoer()方法来返回AndroidInjector\&lt;XxApplication>Dagger提供的基本类型：DaggerActivityDaggerFragmentDaggerServiceDaggerIntentServiceDaggerBroadcastReceiverDaggerContentProvider github-dagger-demo Dagger 2从浅到深 Dagger2 Dagger2 最清晰的使用教程]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(ConstraintLayout)]]></title>
    <url>%2F2018%2F03%2F10%2FAndroid-Notes-ConstraintLayout%2F</url>
    <content type="text"><![CDATA[引入constraint-layout 12345678910allprojects &#123; repositories &#123; jcenter() maven &#123; url &apos;https://maven.google.com&apos; &#125; &#125;&#125;compile &apos;com.android.support.constraint:constraint-layout:1.1.0-beta5&apos; 属性 1234567891011121314151617181920212223layout_constraintLeft_toLeftOf左对齐layout_constraintLeft_toRightOf左边和约束控件的右边对齐layout_constraintRight_toLeftOf右边在某组件的左边layout_constraintRight_toRightOf右边在某组件的右边layout_constraintTop_toTopOf上边和某组件的上边对其layout_constraintTop_toBottomOf上边在某组件的下边layout_constraintBottom_toTopOf下边在某组件的上边layout_constraintBottom_toBottomOf下边在某组件的下边layout_constraintBaseline_toBaselineOf组件的基线位置和某组件的基线位置对其（很少用）layout_constraintStart_toEndOflayout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf属性的值有两种，一种是同层级组件ID，还有就是parent，当值为parent时即是相对于父布局进行定位 偏移设置为0～1之间的值，需要设置上面的水平或垂直相对位置，相应属性： 123456789101112layout_constraintHorizontal_bias // 水平偏移layout_constraintVertical_bias // 垂直偏移设置一个float值，表示宽高比app:layout_constraintDimensionRatio=&quot;2&quot;使用比值app:layout_constraintDimensionRatio=&quot;16:9&quot;或者app:layout_constraintDimensionRatio=&quot;w,16:9&quot;app:layout_constraintDimensionRatio=&quot;h,16:9&quot;这种方式，如果没有前缀就代表是宽高比，如果加了前缀H代表比值的第一个数字是高度，W是宽度 add chain autoconnect guideline 距parent默认margin是16dp change margin,adjust bias,达到铺满屏幕效果，不能用match_parent，设置0dp-&gt;match_constraint 设置基线约束 packtool 铺满view所在方向的可用空间 Infer Constraints tool 通过计算，给所有元素增加约束，而AutoConnect只针对selected element to the element’s parent. 设置View比例 设置Barrier，修改barrier direction1Barriers start with their barrierDirection set to left. Make sure you update your barrierDirection to right or end. 添加chains,设置margin为0 1234The modes are, in order:Packed: The elements are packed together, as shown above.Spread: The elements are spread out over the available space.Spread inside: Similar to Spread, but the endpoints of the chain are not spread out.]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(CoordinatorLayout)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-CoordinatorLayout%2F</url>
    <content type="text"><![CDATA[CoordinatorLayout build.gradle 123456789def SUPPORT = &quot;26.1.0&quot;dependencies &#123; implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; implementation &quot;com.android.support:design:$SUPPORT&quot; implementation &quot;com.android.support:cardview-v7:$SUPPORT&quot; implementation &quot;com.android.support:recyclerview-v7:$SUPPORT&quot; implementation &apos;de.hdodenhof:circleimageview:1.3.0&apos;&#125; styles.xml 123456789&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;!--&lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;true&lt;/item&gt;--&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; &lt;/style&gt; activity_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.willkernel.app.coordinatorlayoutdemo.MainActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appBarLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/main.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:fitsSystemWindows=&quot;true&quot; android:elevation=&quot;4dp&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot; android:title=&quot;@string/app_name&quot; app:title=&quot;@string/app_name&quot; /&gt; &lt;!--android:background=&quot;?attr/colorPrimary&quot;--&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;8dp&quot; app:contentPadding=&quot;8dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/main.coordinator.textview&quot; style=&quot;@style/TextItem&quot; android:text=&quot;@string/item_simple_coordinator_example&quot; /&gt; &lt;TextView android:id=&quot;@+id/main.ioexample.textview&quot; style=&quot;@style/TextItem&quot; android:text=&quot;@string/item_googleio_example&quot; /&gt; &lt;TextView android:id=&quot;@+id/main.materialup.textview&quot; style=&quot;@style/TextItem&quot; android:text=&quot;@string/item_materialup_example&quot; /&gt; &lt;TextView android:id=&quot;@+id/main.space.textview&quot; style=&quot;@style/TextItem&quot; android:text=&quot;@string/item_flexible_space_example&quot; /&gt; &lt;TextView android:id=&quot;@+id/main.swipebehavior.textview&quot; style=&quot;@style/TextItem&quot; android:text=&quot;Swype Behavior example&quot; /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;android.support.v7.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;8dp&quot; app:contentPadding=&quot;8dp&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:lineSpacingExtra=&quot;6dp&quot; android:text=&quot;@string/about&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; MaintActivity.java 12Toolbar toolbar=findViewById(R.id.main_toolbar);setSupportActionBar(toolbar);//控制toolbar内部bottom边距 SimpleAppbarLayout 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:background=&quot;@android:color/background_light&quot;android:fitsSystemWindows=&quot;true&quot;&gt;&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/main.appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/main.collapsing&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;?attr/colorAccent&quot; app:expandedTitleMarginEnd=&quot;46dp&quot; app:expandedTitleMarginStart=&quot;46dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:scrimAnimationDuration=&quot;1000&quot; app:title=&quot;@string/app_name&quot; app:titleEnabled=&quot;true&quot;&gt; &lt;!--app:scrimAnimationDuration=&quot;1000&quot; 颜色过度持续时间--&gt; &lt;!-- app:expandedTitleMarginStart 展开时标题的内边距--&gt; &lt;!-- app:contentScrim=&quot;?attr/colorAccent&quot; 折叠时内容背景颜色--&gt; &lt;!-- app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; 和 android:minHeight=&quot;200dp&quot; 控制--&gt; &lt;ImageView android:id=&quot;@+id/main.backdrop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;200dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/material_flat&quot; app:layout_collapseMode=&quot;parallax&quot; app:layout_collapseParallaxMultiplier=&quot;0.7&quot; /&gt; &lt;!-- app:layout_collapseParallaxMultiplier=&quot;0.7&quot; app:layout_collapseMode=&quot;parallax&quot; 两者结合使用--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/main.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:fitsSystemWindows=&quot;true&quot; android:title=&quot;toolbar&quot; app:layout_collapseMode=&quot;parallax&quot; app:title=&quot;toolbar&quot; /&gt; &lt;!--在titleEnabled=true时，app:title=&quot;toolbar&quot; android:title=&quot;toolbar&quot;设置标题无效&quot;--&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:lineSpacingExtra=&quot;8dp&quot; android:padding=&quot;@dimen/activity_horizontal_margin&quot; android:text=&quot;@string/about&quot; android:textSize=&quot;20sp&quot; /&gt;&lt;/android.support.v4.widget.NestedScrollView&gt;&lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;@dimen/activity_horizontal_margin&quot; android:src=&quot;@mipmap/ic_launcher&quot; app:layout_anchor=&quot;@id/main.appbar&quot; app:layout_anchorGravity=&quot;bottom|right|end&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; AppBarStateChangeListener 123456789101112131415161718192021222324252627282930public abstract class AppBarStateChangeListener implements AppBarLayout.OnOffsetChangedListener &#123; public enum State &#123; EXPANDED, COLLAPSED, IDLE &#125; private State mCurrentState = State.IDLE; @Override public final void onOffsetChanged(AppBarLayout appBarLayout, int i) &#123; if (i == 0) &#123; if (mCurrentState != State.EXPANDED) &#123; onStateChanged(appBarLayout, State.EXPANDED); &#125; mCurrentState = State.EXPANDED; &#125; else if (Math.abs(i) &gt;= appBarLayout.getTotalScrollRange()) &#123; if (mCurrentState != State.COLLAPSED) &#123; onStateChanged(appBarLayout, State.COLLAPSED); &#125; mCurrentState = State.COLLAPSED; &#125; else &#123; if (mCurrentState != State.IDLE) &#123; onStateChanged(appBarLayout, State.IDLE); &#125; mCurrentState = State.IDLE; &#125;&#125; public abstract void onStateChanged(AppBarLayout appBarLayout, State state);&#125; SimpleCoordinatorActivity 123456789101112131415161718//沉浸式状态栏// if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;//5.0之上// getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);// getWindow().setStatusBarColor(Color.RED);// &#125; setContentView(R.layout.activity_simple_coordinator); AppBarLayout main_appbar = findViewById(R.id.main_appbar); main_appbar.addOnOffsetChangedListener(stateListener()); Toolbar toolbar=findViewById(R.id.main_toolbar); setSupportActionBar(toolbar); CollapsingToolbarLayout mCollapsingToolbarLayout = findViewById(R.id.main_collapsing); //通过CollapsingToolbarLayout修改字体颜色 mCollapsingToolbarLayout.setExpandedTitleColor(Color.RED);//设置还没收缩时状态下字体颜色 mCollapsingToolbarLayout.setCollapsedTitleTextColor(Color.GREEN);//设置收缩后Toolbar上字体的颜色 Title+Subtitle+NavigationIcon,Toolbar固定并在图片下方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/io.appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:contentScrim=&quot;?attr/colorPrimary&quot; app:expandedTitleMarginEnd=&quot;64dp&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;!--app:contentScrim=&quot;?attr/colorPrimary&quot; 没有标题时也要设置背景颜色，不然在滚动的时候有toolbar缺失上半部--&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/material_flat&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;56dp&quot; android:lineSpacingExtra=&quot;8dp&quot; android:text=&quot;@string/about&quot; /&gt;&lt;/android.support.v4.widget.NestedScrollView&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/io.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;112dp&quot; android:background=&quot;?attr/colorAccent&quot; android:elevation=&quot;4dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:layout_anchor=&quot;@id/io.appbar&quot; app:layout_anchorGravity=&quot;bottom&quot; android:paddingTop=&quot;16dp&quot; app:layout_collapseMode=&quot;pin&quot; app:navigationIcon=&quot;@drawable/abc_ic_ab_back_material&quot; app:subtitle=&quot;subtitle&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:title=&quot;@string/app_name&quot;&gt; &lt;!--android:elevation=&quot;4dp&quot; 增加阴影，边界过度更自然--&gt; &lt;!--&lt;LinearLayout--&gt; &lt;!--android:layout_width=&quot;match_parent&quot;--&gt; &lt;!--android:layout_height=&quot;wrap_content&quot;--&gt; &lt;!--android:layout_gravity=&quot;bottom&quot;--&gt; &lt;!--android:layout_marginBottom=&quot;8dp&quot;--&gt; &lt;!--android:minHeight=&quot;?android:attr/actionBarSize&quot;--&gt; &lt;!--android:orientation=&quot;vertical&quot;&gt;--&gt; &lt;!--&lt;TextView--&gt; &lt;!--android:layout_width=&quot;match_parent&quot;--&gt; &lt;!--android:layout_height=&quot;wrap_content&quot;--&gt; &lt;!--android:text=&quot;@string/app_name&quot;--&gt; &lt;!--android:textAppearance=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse&quot; /&gt;--&gt; &lt;!--&lt;TextView--&gt; &lt;!--android:layout_width=&quot;match_parent&quot;--&gt; &lt;!--android:layout_height=&quot;wrap_content&quot;--&gt; &lt;!--android:layout_marginTop=&quot;4dp&quot;--&gt; &lt;!--android:text=&quot;subtitle&quot;--&gt; &lt;!--android:textAppearance=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle.Inverse&quot; /&gt;--&gt; &lt;!--&lt;/LinearLayout&gt;--&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125; &#125;); Navigation+TabLayout+ViewPager+CircleImage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/profile.appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; app:contentScrim=&quot;?attr/colorAccent&quot; app:expandedTitleMarginEnd=&quot;64dp&quot; app:expandedTitleMarginStart=&quot;48dp&quot; app:layout_scrollFlags=&quot;scroll|snap&quot;&gt; &lt;!--app:contentScrim=&quot;?attr/colorPrimary&quot; 没有标题时也要设置背景颜色，不然在滚动的时候有toolbar缺失上半部--&gt; &lt;ImageView android:id=&quot;@+id/profile.image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/material_flat&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/profile.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorAccent&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:paddingTop=&quot;16dp&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; app:navigationIcon=&quot;@drawable/abc_ic_ab_back_material&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;LinearLayout android:id=&quot;@+id/profile.title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; android:paddingTop=&quot;@dimen/activity_horizontal_margin&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/app_name&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:gravity=&quot;center&quot; android:text=&quot;subtitle&quot; android:textAppearance=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle.Inverse&quot; /&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/profile.tablayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?android:attr/actionBarSize&quot; android:paddingTop=&quot;24dp&quot; app:tabIndicatorColor=&quot;?android:attr/textColorPrimaryInverse&quot; app:tabIndicatorHeight=&quot;4dp&quot; app:tabSelectedTextColor=&quot;?android:attr/textColorPrimaryInverse&quot; /&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v4.view.ViewPager android:id=&quot;@+id/profile.viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;&lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right|end&quot; android:layout_margin=&quot;16dp&quot; android:elevation=&quot;8dp&quot; /&gt;&lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/profile.avatar&quot; android:layout_width=&quot;96dp&quot; android:layout_height=&quot;96dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:elevation=&quot;8dp&quot; android:src=&quot;@mipmap/user_avatar&quot; app:border_color=&quot;#FFF&quot; app:border_width=&quot;2dp&quot; app:layout_anchor=&quot;@id/profile.title&quot; app:layout_anchorGravity=&quot;center_horizontal|top&quot; app:layout_scrollFlags=&quot;scroll&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; ProfileActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 profile_avatar = findViewById(R.id.profile_avatar); TabLayout tabLayout = findViewById(R.id.profile_tablayout); ViewPager viewPager = findViewById(R.id.profile_viewpager); AppBarLayout appBarLayout = findViewById(R.id.profile_appbar); appBarLayout.addOnOffsetChangedListener(this); mMaxScrollSize = appBarLayout.getTotalScrollRange(); viewPager.setAdapter(new TabsAdapter(getSupportFragmentManager())); tabLayout.setupWithViewPager(viewPager); Toolbar toolbar = findViewById(R.id.profile_toolbar); toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125; &#125;);&#125;public static void start(Context c) &#123; c.startActivity(new Intent(c, MaterialUpConceptActivity.class));&#125;@Overridepublic void onOffsetChanged(AppBarLayout appBarLayout, int i) &#123; if (mMaxScrollSize == 0) &#123; mMaxScrollSize = appBarLayout.getTotalScrollRange(); &#125; int percent = Math.abs(i) * 100 / mMaxScrollSize; if (percent &gt;= PERCENTAGE_TO_ANIMATE_AVATAR &amp;&amp; mIsAvatarShown) &#123; mIsAvatarShown = false; profile_avatar.animate().scaleX(0).scaleY(0).setDuration(200).start(); &#125; if (percent &lt;= PERCENTAGE_TO_ANIMATE_AVATAR &amp;&amp; !mIsAvatarShown) &#123; mIsAvatarShown = true; profile_avatar.animate().scaleX(1).scaleY(1).setDuration(200).start(); &#125;&#125;private class TabsAdapter extends FragmentPagerAdapter &#123; private static final int TAB_COUNT = 2; public TabsAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return MyFragment.newInstance(); &#125; @Override public int getCount() &#123; return TAB_COUNT; &#125; @Override public CharSequence getPageTitle(int position) &#123; return &quot;Tab&quot; + position; &#125;&#125; MyFragment 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private RecyclerView rootView; public static MyFragment newInstance() &#123; return new MyFragment(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; rootView = (RecyclerView) inflater.inflate(R.layout.fragment_page, container, false); return rootView; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); initRecyclerView(); &#125; private void initRecyclerView() &#123; rootView.setAdapter(new MyPageAdapter(10)); &#125; private class MyPageAdapter extends RecyclerView.Adapter&lt;MyVH&gt; &#123; private final int count; public MyPageAdapter(int count) &#123; this.count = count; &#125; @Override public MyVH onCreateViewHolder(ViewGroup parent, int viewType) &#123; View item = LayoutInflater.from(parent.getContext()) .inflate(R.layout.list_item_card, parent, false); return new MyVH(item); &#125; @Override public void onBindViewHolder(MyVH holder, int position) &#123; &#125; @Override public int getItemCount() &#123; return count; &#125; &#125; private class MyVH extends RecyclerView.ViewHolder &#123; public MyVH(View itemView) &#123; super(itemView); &#125; &#125; fragment_page.xml 123456789&lt;android.support.v7.widget.RecyclerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;android:id=&quot;@+id/recycler_view&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:scrollbars=&quot;vertical&quot;app:layoutManager=&quot;android.support.v7.widget.LinearLayoutManager&quot;tools:listitem=&quot;@layout/list_item_card&quot; /&gt; 图片被内容覆盖一部分，形成上下两层，FAB跟随AppbarLayout放大缩小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/flex.appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:contentScrim=&quot;?attr/colorAccent&quot; app:expandedTitleMarginBottom=&quot;90dp&quot; app:expandedTitleMarginStart=&quot;32dp&quot; app:layout_scrollFlags=&quot;scroll|snap|exitUntilCollapsed&quot; app:title=&quot;flex&quot;&gt; &lt;!--app:expandedTitleMarginBottom=&quot;90dp&quot; 被遮挡后需要设置底部内边距--&gt; &lt;ImageView android:id=&quot;@+id/flex.image&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/material_flat&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/flex.toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?android:attr/actionBarSize&quot; android:layout_marginTop=&quot;@dimen/activity_horizontal_margin&quot; android:background=&quot;@null&quot; app:layout_collapseMode=&quot;pin&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; app:navigationIcon=&quot;@drawable/abc_ic_ab_back_material&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt;&lt;android.support.v4.widget.NestedScrollView android:id=&quot;@+id/flex.scroll&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:behavior_overlapTop=&quot;78dp&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;!--app:behavior_overlapTop=&quot;78dp&quot; 图片被可滚动的ScrollView覆盖内容--&gt; &lt;android.support.v7.widget.CardView android:id=&quot;@+id/flex.cardview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;8dp&quot; app:cardBackgroundColor=&quot;@android:color/white&quot; app:cardCornerRadius=&quot;4dp&quot; app:cardElevation=&quot;4dp&quot; app:contentPaddingBottom=&quot;16dp&quot; app:contentPaddingLeft=&quot;16dp&quot; app:contentPaddingRight=&quot;16dp&quot;&gt; &lt;TextView android:id=&quot;@+id/flex.text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/about&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/android.support.v4.widget.NestedScrollView&gt;&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/flex.fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:elevation=&quot;8dp&quot; app:layout_anchor=&quot;@id/flex.cardview&quot; app:layout_anchorGravity=&quot;end|right&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; FlexActivity.java 1234567891011121314151617181920212223242526272829private static final int PERCENTAGE_TO_SHOW_IMAGE = 20;appBarLayout.addOnOffsetChangedListener(this); mFab = findViewById(R.id.flex_fab); Toolbar toolbar = findViewById(R.id.flex_toolbar); toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125; &#125;);&#125;@Overridepublic void onOffsetChanged(AppBarLayout appBarLayout, int i) &#123; if (mMaxScrollSize == 0) &#123; mMaxScrollSize = appBarLayout.getTotalScrollRange(); &#125; if (mMaxScrollSize == 0) return; int currentScrollPercentage = (Math.abs(i)) * 100 / mMaxScrollSize; if (currentScrollPercentage &gt;= PERCENTAGE_TO_SHOW_IMAGE &amp;&amp; !mIsImageHidden) &#123; mIsImageHidden = true; mFab.animate().scaleX(0).scaleY(0).start(); &#125; if (currentScrollPercentage &lt; PERCENTAGE_TO_SHOW_IMAGE &amp;&amp; mIsImageHidden) &#123; mIsImageHidden = false; mFab.animate().scaleX(1).scaleY(1).start(); &#125;&#125; 设置CardView在CoordinatorLayout中的滑动移除Behavior123456789101112131415161718SwipeDismissBehavior swipeDismissBehavior = new SwipeDismissBehavior(); swipeDismissBehavior.setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_ANY); swipeDismissBehavior.setListener(new SwipeDismissBehavior.OnDismissListener() &#123; @Override public void onDismiss(View view) &#123; Toast.makeText(SwipeBehaviorExampleActivity.this, &quot;Card swiped !!&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onDragStateChanged(int state) &#123; &#125; &#125;);CardView cardView = findViewById(R.id.swipe_card);LayoutParams layoutParams = (LayoutParams) cardView.getLayoutParams();layoutParams.setBehavior(swipeDismissBehavior);]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(NDK)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-NDK%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Git)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-Git%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Kotlin)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-Kotlin%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(MVP)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-MVP%2F</url>
    <content type="text"><![CDATA[MVP概念 View视图层,包含各种界面相关功能，例如Activity，Fragment，View,Adapter,专注于交互，一般持有Presenter的引用，或者通过依赖注入(Dagger)方式获得Presenter实例，将非UI逻辑操作委托给Presenter Presenter逻辑控制层，充当中间人，隔离View层，Model层，接收View层的数据请求，分发给Model层处理，监听Model处理结果，将结果反馈给View，实项界面的刷新 Model封装网络数据请求，本地数据请求，对Presenter提供简单易用的接口 MVP，MVC区别 MVP中Presenter和View，Model通过接口进行通信，通常Presenter与View是一一对应，复杂的可能有多个Presenter MVC中Model,View直接通信的，Controller基于行为，可以被多个View共享 (以下项目来自android-architecture-todoapp) mvp BaseView 123public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; BasePresenter 123public interface BasePresenter &#123; void start();&#125; TaskContract接口包装Presenter,View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface View extends BaseView&lt;Presenter&gt; &#123; void setLoadingIndicator(boolean active); void showTasks(List&lt;Task&gt; tasks); void showAddTask(); void showTaskDetailsUi(String taskId); void showTaskMarkedComplete(); void showTaskMarkedActive(); void showCompletedTasksCleared(); void showLoadingTasksError(); void showNoTasks(); void showActiveFilterLabel(); void showCompletedFilterLabel(); void showAllFilterLabel(); void showNoActiveTasks(); void showNoCompletedTasks(); void showSuccessfullySavedMessage(); boolean isActive(); void showFilteringPopUpMenu(); &#125; interface Presenter extends BasePresenter &#123; void result(int requestCode, int resultCode); void loadTasks(boolean forceUpdate); void addNewTask(); void openTaskDetails(@NonNull Task requestedTask); void completeTask(@NonNull Task completedTask); void activateTask(@NonNull Task activeTask); void clearCompletedTasks(); void setFiltering(TasksFilterType requestType); TasksFilterType getFiltering(); &#125; TaskPresenter 实现TaskContract.Presenter,持有TaskContract.View对象，在Activity中初始化并传入View，Model 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class TasksPresenter implements TasksContract.Presenter &#123; private final TasksRepository mTasksRepository; private final TasksContract.View mTasksView; public TasksPresenter(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView) &#123; mTasksRepository = checkNotNull(tasksRepository, &quot;tasksRepository cannot be null&quot;); mTasksView = checkNotNull(tasksView, &quot;tasksView cannot be null!&quot;); //View必须实现TasksContract.View mTasksView.setPresenter(this);&#125; mTasksRepository.getTasks(new TasksDataSource.LoadTasksCallback() &#123; @Override public void onTasksLoaded(List&lt;Task&gt; tasks) &#123; List&lt;Task&gt; tasksToShow = new ArrayList&lt;Task&gt;(); // This callback may be called twice, once for the cache and once for loading // We filter the tasks based on the requestType for (Task task : tasks) &#123; switch (mCurrentFiltering) &#123; case ALL_TASKS: tasksToShow.add(task); break; case ACTIVE_TASKS: if (task.isActive()) &#123; tasksToShow.add(task); &#125; break; case COMPLETED_TASKS: if (task.isCompleted()) &#123; tasksToShow.add(task); &#125; break; default: tasksToShow.add(task); break; &#125; &#125; // The view may not be able to handle UI updates anymore if (!mTasksView.isActive()) &#123; return; &#125; if (showLoadingUI) &#123; mTasksView.setLoadingIndicator(false); &#125; processTasks(tasksToShow); &#125; @Override public void onDataNotAvailable() &#123; // The view may not be able to handle UI updates anymore if (!mTasksView.isActive()) &#123; return; &#125; mTasksView.showLoadingTasksError(); &#125; &#125;); TasksFragment 持有TasksContract.Presenter对象,并实现TasksContract.View,Fragment实例化后在Presenter中taskView.setPresenter(this),在taskView中通过Presenter获取数据,并在Presenter中刷新内容，在taskView中响应 1234567public class TasksFragment extends Fragment implements TasksContract.Viewprivate TasksContract.Presenter mPresenter;@Overridepublic void setPresenter(@NonNull TasksContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter);&#125; TaskActivity 1234567891011TasksFragment tasksFragment =(TasksFragment)getSupportFragmentManager().findFragmentById(R.id.contentFrame);if (tasksFragment == null) &#123; // Create the fragment tasksFragment = TasksFragment.newInstance(); ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), tasksFragment, R.id.contentFrame);&#125;// Create the presentermTasksPresenter = new TasksPresenter(Injection.provideTasksRepository(getApplicationContext()), tasksFragment);//set filtermTasksPresenter.setFiltering(currentFiltering); ToDoDatabase RoomDatabase包含一个Task表 123456789101112131415161718192021@Database(entities = &#123;Task.class&#125;, version = 1)public abstract class ToDoDatabase extends RoomDatabase &#123; private static ToDoDatabase INSTANCE; public abstract TasksDao taskDao(); private static final Object sLock = new Object(); public static ToDoDatabase getInstance(Context context) &#123; synchronized (sLock) &#123; if (INSTANCE == null) &#123; INSTANCE = Room.databaseBuilder(context.getApplicationContext(), ToDoDatabase.class, &quot;Tasks.db&quot;) .build(); &#125; return INSTANCE; &#125; &#125;&#125; TasksDao 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Daopublic interface TasksDao &#123; /** * Select all tasks from the tasks table. * * @return all tasks. */ @Query(&quot;SELECT * FROM Tasks&quot;) List&lt;Task&gt; getTasks(); /** * Select a task by id. * * @param taskId the task id. * @return the task with taskId. */ @Query(&quot;SELECT * FROM Tasks WHERE entryid = :taskId&quot;) Task getTaskById(String taskId); /** * Insert a task in the database. If the task already exists, replace it. * * @param task the task to be inserted. */ @Insert(onConflict = OnConflictStrategy.REPLACE) void insertTask(Task task); /** * Update a task. * * @param task task to be updated * @return the number of tasks updated. This should always be 1. */ @Update int updateTask(Task task); /** * Update the complete status of a task * * @param taskId id of the task * @param completed status to be updated */ @Query(&quot;UPDATE tasks SET completed = :completed WHERE entryid = :taskId&quot;) void updateCompleted(String taskId, boolean completed); /** * Delete a task by id. * * @return the number of tasks deleted. This should always be 1. */ @Query(&quot;DELETE FROM Tasks WHERE entryid = :taskId&quot;) int deleteTaskById(String taskId); /** * Delete all tasks. */ @Query(&quot;DELETE FROM Tasks&quot;) void deleteTasks(); /** * Delete all completed tasks from the table. * * @return the number of tasks deleted. */ @Query(&quot;DELETE FROM Tasks WHERE completed = 1&quot;) int deleteCompletedTasks();&#125; TasksLocalDataSource 1234567891011@Override public void saveTask(@NonNull final Task task) &#123; checkNotNull(task); Runnable saveRunnable = new Runnable() &#123; @Override public void run() &#123; mTasksDao.insertTask(task); &#125; &#125;; mAppExecutors.diskIO().execute(saveRunnable); &#125; 保存数据 1mTasksRepository.saveTask(new Task(title, description, mTaskId)); DiskIOThreadExecutor 12345678910111213public class DiskIOThreadExecutor implements Executor &#123; private final Executor mDiskIO; public DiskIOThreadExecutor() &#123; mDiskIO = Executors.newSingleThreadExecutor(); &#125; @Override public void execute(@NonNull Runnable command) &#123; mDiskIO.execute(command); &#125;&#125; mvp-loader Presenter中持有View，Loader，LoaderManager(提供异步加载)，Repository,当数据发生变化时，Loader自动刷新View 123456789101112public class TasksPresenter implements TasksContract.Presenter, LoaderManager.LoaderCallbacks&lt;List&lt;Task&gt;&gt; &#123; private final static int TASKS_QUERY = 1; private final TasksRepository mTasksRepository; private final TasksContract.View mTasksView; private final TasksLoader mLoader; private final LoaderManager mLoaderManager; TaskRepository,在MVP中需要回调刷新View，而在Loader机制中自动刷新 12345678910111213141516171819202122232425262728293031323334353637383940414243private final TasksDataSource mTasksRemoteDataSource;private final TasksDataSource mTasksLocalDataSource;private List&lt;TasksRepositoryObserver&gt; mObservers = new ArrayList&lt;TasksRepositoryObserver&gt;();// Update the UInotifyContentObserver();···//从缓存Map中获取数据Map&lt;String, Task&gt; mCachedTasks;public List&lt;Task&gt; getCachedTasks() &#123; return mCachedTasks == null ? null : new ArrayList&lt;&gt;(mCachedTasks.values());&#125;public Task getCachedTask(String taskId) &#123; return mCachedTasks.get(taskId);&#125;//获取任务@Nullable@Overridepublic List&lt;Task&gt; getTasks() &#123; List&lt;Task&gt; tasks = null; if (!mCacheIsDirty) &#123; // Respond immediately with cache if available and not dirty if (mCachedTasks != null) &#123; tasks = getCachedTasks(); return tasks; &#125; else &#123; // Query the local storage if available. tasks = mTasksLocalDataSource.getTasks(); &#125; &#125; // To simplify, we&apos;ll consider the local data source fresh when it has data. if (tasks == null || tasks.isEmpty()) &#123; // Grab remote data if cache is dirty or local data not available. tasks = mTasksRemoteDataSource.getTasks(); // We copy the data to the device so we don&apos;t need to query the network next time saveTasksInLocalDataSource(tasks); &#125; processLoadedTasks(tasks); return getCachedTasks();&#125; Fragment中涉及Loader加载数据，自动刷新流程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 //在Activity中对Loader,LoaderManager,Presenter实例化 // Create the presenter TasksRepository repository = Injection.provideTasksRepository(getApplicationContext()); TasksLoader tasksLoader = new TasksLoader(getApplicationContext(), repository); mTasksPresenter = new TasksPresenter( tasksLoader, getSupportLoaderManager(), repository, tasksFragment ); //FragmentManager的performStart()中也有回调LoadFinished()针对有缓存数据时刷新View void performStart() &#123; ··· onStart(); ··· if (mLoaderManager != null) &#123; mLoaderManager.doReportStart(); &#125; &#125; //Fragment的onResume()对LoadManager进行初始化 @Override public void onResume() &#123; super.onResume(); mPresenter.start(); &#125; //Presenter初始化 @Override public void start() &#123; mLoaderManager.initLoader(TASK_QUERY, null, this); &#125; //LoadManager开始加载 void start()&#123; mLoader.startLoading(); &#125; //LoaderManager中加载完成后回调callOnLoadFinished void finishRetain() &#123; ··· callOnLoadFinished(mLoader, mData); &#125; void reportStart() &#123; if (mStarted) &#123; if (mReportNextStart) &#123; mReportNextStart = false; if (mHaveData &amp;&amp; !mRetaining) &#123; callOnLoadFinished(mLoader, mData); &#125; &#125; &#125; &#125; //Presenter加载数据 public void loadTasks(boolean forceUpdate) &#123; if (forceUpdate || mFirstLoad) &#123; mFirstLoad = false; mTasksRepository.refreshTasks(); &#125; else &#123; showFilteredTasks(); &#125; &#125; //加载完成后 @Override public void onLoadFinished(Loader&lt;List&lt;Task&gt;&gt; loader, List&lt;Task&gt; data) &#123; mTasksView.setLoadingIndicator(false); mCurrentTasks = data; if (mCurrentTasks == null) &#123; mTasksView.showLoadingTasksError(); &#125; else &#123; showFilteredTasks(); &#125; &#125; //Presenter处理数据返回结果 private void processTasks(List&lt;Task&gt; tasks) &#123; if (tasks.isEmpty()) &#123; // Show a message indicating there are no tasks for that filter type. processEmptyTasks(); &#125; else &#123; // Show the list of tasks mTasksView.showTasks(tasks); // Set the filter label&apos;s text. showFilterLabel(); &#125; &#125; //Fragment显示数据@Override public void showTasks(List&lt;Task&gt; tasks) &#123; mListAdapter.replaceData(tasks); mTasksView.setVisibility(View.VISIBLE); mNoTasksView.setVisibility(View.GONE); &#125; mvp-dagger DaggerApplication 注入Activity,Fragment,Service,BroadService,ContentProvider等成员,并在相应类中的onCreate()/onAttach()/onCreate()/onReceive()/onCreate()注入 1AndroidInjection.inject(this); DaggerApplication 123456789101112public abstract class DaggerApplication extends Application implements HasActivityInjector, HasFragmentInjector, HasServiceInjector, HasBroadcastReceiverInjector, HasContentProviderInjector &#123; @Inject DispatchingAndroidInjector&lt;Activity&gt; activityInjector; @Inject DispatchingAndroidInjector&lt;BroadcastReceiver&gt; broadcastReceiverInjector; @Inject DispatchingAndroidInjector&lt;Fragment&gt; fragmentInjector; @Inject DispatchingAndroidInjector&lt;Service&gt; serviceInjector; @Inject DispatchingAndroidInjector&lt;ContentProvider&gt; contentProviderInjector; ToDoApplication 1234567891011121314public class ToDoApplication extends DaggerApplication &#123; @Inject TasksRepository tasksRepository; @Override protected AndroidInjector&lt;? extends DaggerApplication&gt; applicationInjector() &#123; return DaggerAppComponent.builder().application(this).build(); &#125; @VisibleForTesting public TasksRepository getTasksRepository() &#123; return tasksRepository; &#125;&#125; ApplicationModule 通过AppComponent依赖注入，提供给子组件Context实例 123456@Modulepublic abstract class ApplicationModule &#123; //expose Application as an injectable context @Binds abstract Context bindContext(Application application);&#125; AppComponent 在Dagger.Android中自动生成并定位子组件 123456789101112131415161718192021@Singleton@Component(modules = &#123;TasksRepositoryModule.class, ApplicationModule.class, ActivityBindingModule.class, AndroidSupportInjectionModule.class&#125;)public interface AppComponent extends AndroidInjector&lt;ToDoApplication&gt; &#123; TasksRepository getTasksRepository(); // Gives us syntactic sugar. we can then do DaggerAppComponent.builder().application(this).build().inject(this); // never having to instantiate any modules or say which module we are passing the application to. // Application will just be provided into our app graph now. @Component.Builder interface Builder &#123; @BindsInstance AppComponent.Builder application(Application application); AppComponent build(); &#125;&#125; TasksRepositoryModule 123456789101112131415161718192021222324252627282930313233343536@Moduleabstract public class TasksRepositoryModule &#123; private static final int THREAD_COUNT = 3; @Singleton @Binds @Local abstract TasksDataSource provideTasksLocalDataSource(TasksLocalDataSource dataSource); @Singleton @Binds @Remote abstract TasksDataSource provideTasksRemoteDataSource(FakeTasksRemoteDataSource dataSource); @Singleton @Provides static ToDoDatabase provideDb(Application context) &#123; return Room.databaseBuilder(context.getApplicationContext(), ToDoDatabase.class, &quot;Tasks.db&quot;) .build(); &#125; @Singleton @Provides static TasksDao provideTasksDao(ToDoDatabase db) &#123; return db.taskDao(); &#125; @Singleton @Provides static AppExecutors provideAppExecutors() &#123; return new AppExecutors(new DiskIOThreadExecutor(), Executors.newFixedThreadPool(THREAD_COUNT), new AppExecutors.MainThreadExecutor()); &#125;&#125; AppExecutors 1234567891011121314151617181920212223242526272829303132333435363738@Singletonpublic class AppExecutors &#123; private static final int THREAD_COUNT = 3; private final Executor diskIO; private final Executor networkIO; private final Executor mainThread; public AppExecutors(Executor diskIO, Executor networkIO, Executor mainThread) &#123; this.diskIO = diskIO; this.networkIO = networkIO; this.mainThread = mainThread; &#125; public Executor diskIO() &#123; return diskIO; &#125; public Executor networkIO() &#123; return networkIO; &#125; public Executor mainThread() &#123; return mainThread; &#125; public static class MainThreadExecutor implements Executor &#123; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) &#123; mainThreadHandler.post(command); &#125; &#125;&#125; TasksModule中的Presenter和View注入到TasksActivity,提供实例 123456789@Modulepublic abstract class TasksModule &#123; @FragmentScoped @ContributesAndroidInjector abstract TasksFragment tasksFragment(); @ActivityScoped @Binds abstract TasksContract.Presenter taskPresenter(TasksPresenter presenter);&#125; ActivityBindingModule,Android 注解处理器自动通过指定的模块生成子组件，并绑定AppComponent父组件，不需要告诉父组件子组件有哪些，也不需要告诉子组件谁是父组件 123456789101112131415161718@Modulepublic abstract class ActivityBindingModule &#123; @ActivityScoped @ContributesAndroidInjector(modules = TasksModule.class) abstract TasksActivity tasksActivity(); @ActivityScoped @ContributesAndroidInjector(modules = AddEditTaskModule.class) abstract AddEditTaskActivity addEditTaskActivity(); @ActivityScoped @ContributesAndroidInjector(modules = StatisticsModule.class) abstract StatisticsActivity statisticsActivity(); @ActivityScoped @ContributesAndroidInjector(modules = TaskDetailPresenterModule.class) abstract TaskDetailActivity taskDetailActivity();&#125; TasksActivity 123456public class TasksActivity extends DaggerAppCompatActivity &#123; @Inject TasksPresenter mTasksPresenter; @Inject Lazy&lt;TasksFragment&gt; taskFragmentProvider;&#125; TasksFragment 123456789@ActivityScopedpublic class TasksFragment extends DaggerFragment implements TasksContract.View &#123; @Inject TasksContract.Presenter mPresenter; @Injectpublic TasksFragment() &#123; // Requires empty public constructor &#125; TasksPresenter 12345678910@ActivityScopedfinal class TasksPresenter implements TasksContract.Presenter &#123; private final TasksRepository mTasksRepository; @Nullable private TasksContract.View mTasksView; @Inject TasksPresenter(TasksRepository tasksRepository) &#123; mTasksRepository = tasksRepository; &#125; TasksRepository 123456789@Singletonpublic class TasksRepository implements TasksDataSource &#123; @Inject TasksRepository(@Remote TasksDataSource tasksRemoteDataSource, @Local TasksDataSource tasksLocalDataSource) &#123; mTasksRemoteDataSource = tasksRemoteDataSource; mTasksLocalDataSource = tasksLocalDataSource; &#125; 在TasksActivity中通过依赖注入@Inject,TasksPresenter,TasksRepository,TasksFragment已经实例化 ActivityScope,FragmentScope 12345678910@Documented@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScoped &#123;&#125;@Scope@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface FragmentScoped &#123;&#125; ToDoDatabase 1234@Database(entities = &#123;Task.class&#125;, version = 1)public abstract class ToDoDatabase extends RoomDatabase &#123; public abstract TasksDao taskDao();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(MVVM)]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Notes-MVVM%2F</url>
    <content type="text"><![CDATA[Todo-mvvm-databinding]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Performance)]]></title>
    <url>%2F2018%2F03%2F08%2FAndroid-Notes-Performance%2F</url>
    <content type="text"><![CDATA[Performance optimization布局 人眼感觉流畅画面的帧数要达到40-60帧每秒 在Android中，系统通过VSYNC信号触发对UI的渲染，重绘，需要16ms,其实就是1000ms中显示60帧，1000/60=16.67.如果不能在16ms完成绘制，就会丢帧，例如绘制耗时20ms，在16ms有VSYNC信号时无法绘制，该帧被丢弃，等待下次信号才开始绘制，导致16*2ms 都显示同一帧画面 在开发者选项中有Profile GPU Rendering 选中On Screen as bars,中间的绿色横线代表VSYNC时间16ms柱状线包含3个部分 蓝色代表测量绘制Display List的时间 红色代表OpenGL渲染Display List的时间 黄色代表CPU等待GPU处理的时间Android 6.0 OverdrawEnable GPU Overdraw 查看当前区域绘制次数，增大蓝色区域，减少红色区域 移除不需要背景 减少布局层级,降低view树高度，不应超过10层 12&lt;include&gt; 布局中不设置宽高具体值(0dp)&lt;ViewStub&gt; 延时加载，可以使用setVisibility(),inflate()显示View，之后ViewStub就不存在了，被显示的layout代替，不能inflate两次，而View.GONE会在初始化布局的时候就已经添加在布局树中，相比之下ViewStub更有效率 减少使用透明度alpha(会先绘制有颜色，再设置透明度) hierarchy viewer 1234&quot;Tools&quot; menu &gt; Android &gt; Android Device MonitorIn ADM: &quot;Window&quot; Menu &gt; PerspectiveClick on Hierarchy Viewer.Profile Node:Obtain layout times at the top of the Tree View 内存 内存太低出发LMK(Low Memory Killer) 手机内存指RAM，包括 12345寄存器(Registers) 位于处理器内部，速度最快，程序无法控制栈 存放基本类型的数据和对象的引用，对象本身不存放在栈中，而是存放在堆中堆 存放对象和数组，堆中分配的内存由Java虚拟机的回收器GC来管理静态存储区域 存放应用程序运行时一直存在的数据，如静态的数据变量常量池 常量的有序集合，包括基本类型，String和对其他类型，字段，方法的符合引用 当定义一个变量，会在栈中分配内存空间，作用域结束后，会立即被用作新的空间分配。当new一个变量，在堆中分配内存空间，该对象作用域结束后，内存也不会立即回收，等待系统GC回收，内存分析就是分析Heap中的内存状态 12ActivityManager am=getSystemService(Context.ACTIVITY_SERVICE);int heapSize=am.getLargeMemoryClass(); 获取系统内存信息 1adb shell dumpsys procstats 内存监视，Settings-Apps-Running 1adb shell dumpsys meminfo Bitmap优化 列表页面使用缩略图，低质量图片 使用完Bitmap，使用bitmap.recycle()释放资源，Android3.0后Bitmap存放在堆内存中，内存由GC管理，不需要进行释放了 使用内存缓存(LruCache)和硬盘缓存(DiskLruCache)可以更好使用Bitmap 代码优化 常量使用static修饰符 静态方法比普通方法提高15%左右访问速度 减少不必要的成员变量 减少不必要的对象，使用基础类型比使用对象更加节省资源 尽量不适应枚举，少使用迭代器 对Cursor，Receiver,Sensor,File 非常注意对他们的创建，回收，注册，解注册 避免使用IOC框架，IOC通常使用注解，反射实现 使用RenderScript,OpenGL来进行非常复杂的绘图操作 使用SurfaceView 来代替View进行大量的绘图操作 尽量使用绘图缓存，而不是inflate()方法解析视图 工具分析优化 Lint 工具优化代码 Android Profile 监测CPU，Memory，Network TraceView 优化App Debug类开启TarceView 1234&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;onCreate()-&gt;Debug.startMethodTracing()onDestory()-&gt;Debug.stopMethodTracing()adb pull /sdcard/trace_log.trace/local/LOG TraceView日志 Incl CPU Time 某方法占用CPU的时间 Excl CPU Time 某方法本身不包括子方法占用CPU的时间 Incl Real Time 某方法真正执行的时间 Excl Real Time某方法本身不包括子方法执行的时间 Calls+RecurCalls 调用次数+递归回调次数 从Incl CPU Time和Calls+RecurCalls开始进行分析，如果占用时间长，Calls+RecurCalls次数少，就可以是怀疑对象了 MAT 手动查看Heap,判断是否有内存泄漏小技巧：不停点击Cause GC,如果data object的total size有明显变化，就可能有内存泄漏 点击Dump HPROF File,生成.hprof,然后再使用命令转换1hprof-conv com.willkernel.app.audiobar.hprof heap.hprof Dumpsys分析系统状态12345678activity 显示所有Activity栈的信息meminfo 内存信息battery 电池信息package包信息wifi WiFi信息alarm alarm信息procstats 内存状态grep,find 在性能优化bug分析时有用]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(System Info Manager Safety)]]></title>
    <url>%2F2018%2F03%2F08%2FAndroid-Notes-System-Info-Manager-Safety%2F</url>
    <content type="text"><![CDATA[Android System Info android.os.Build 12345678910111213141516171819202122Build.BOARD 主板Build.BRAND 系统定制商Build.SUPPORTED_ABIS CPU指令集Build.DEVICE 设备参数Build.DISPLAY 显示屏参数Build.FINGERPRINT 唯一编号Build.SERIAL 硬件序列号Build.ID 修订版本Build.MANUFACTURER 硬件制造商Build.MODEL 版本Build.HARDWARE 硬件名Build.PRODUCT 手机产品名Build.TAGS Build 标签Build.TYPE Build 类型Build.VERSION.CODENAME 开发代号Build.VERSION.INCREMENTAL 源码控制版本号Build.VERSION.RELEASE 版本字符串Build.VERSION.SDK_INT 版本号// The following properties only make sense for internal engineering builds.Build.HOST Host值Build.USER User名Build.TIME 编译时间 SystemProperty 1234567891011121314151617String getPropertyos.version os版本os.name os名称os.arch os架构user.home Home属性user.name Name属性user.dir Dir属性user.timezone 时区path.separator 路径分隔符line.separator 行分隔符file.separator 文件分隔符java.vendor.url Java vendor url属性java.class.path Java Class属性java.class.version Java Class版本java.vendor Java vendor属性java.version Java版本java.home Java Home属性 应用 123456789101112131415String board=Build.BOARDString brand=Build.BRANDString os_version=System.getProperty(&quot;os.version&quot;)String os_name=System.getProperty(&quot;os.name&quot;)cd system/cat build.prop 查看build信息getprop ro.build.id 获取对应属性值MRA58Kcd proc/ls -al 查看文件详细信息cat cpuinfo 查看cpu信息 PackageManager(应用包信息) 123456789getPackageManager 返回PackageManager对象getApplicationInfo 返回指定包名的ApplicationInfogetApplicationIcon 返回指定包名的IcongetInstalledApplication 以ApplicationInfo形式返回安装的应用getInstalledPackages 以PackageInfo形式返回安装的应用queryIntentActivities 返回指定intent的ResolveInfo对象，Activity集合queryIntentServices 返回指定intent的ResolveInfo对象，Service集合resolveActivity 返回指定intent的ActivityresolveService 返回指定intent的Service 判断APP类型 12345 app.flags&amp;ApplicationInfo.FLAG_SYSTEM!=0为系统应用 app.flags&amp;ApplicationInfo.FLAG_SYSTEM&lt;=0则为第三方应用 特殊情况，系统应用升级后也成为第三方应用 app.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP!=0 app.flags&amp;ApplicationInfo.FLAG_EXTERNAL_STORAGE!=0为安装在SDCard应用List&lt;ApplicationInfo&gt; list=pm.getInstalledApplications(PackManager.GET_UNINSTALLED_PACKAGES/MATCH_UNINSTALLED_PACKAGES); ActivityManager(运行应用程序信息)123456789101112131415161718192021ActivityManager.MemoryInfo 全局内存使用信息availMem 系统可用内存totalMem 总内存threshold 低内存的阈值lowMemory 是否处于低内存Debug.MemoryInfo 进程下的内存信息RunningAppProcessInfoprocessName 进程名pid 进程piduid 进程uidpkgList 该进程下所有包RunningServiceInfoactiveSince 第一次激活的时间，方式foreground 服务是否在前台运行List&lt;RunningAppProcessInfo&gt; list=am.getRunningAppProcess();Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) 查看packages.xml获取系统信息1adb pull data/system/packages.xml 123codepath apk安装路径system/app 存放系统或厂商定制apkdata/app 存放第三方apk Android安全 代码混淆proguard，混淆代码，替换命名，压缩代码，优化编译后的字节码 AndroidManifest 权限声明，权限检查 1234检测操作者权限判断permission名称，如果为空，直接返回DENIED判断UID，如果为0，则为Root权限，不做权限控制；如果为system server的uid，不做权限控制；如果uid与参数中的请求uid不同，则返回DENIEDPackageManagerService.checkUidPermission()判断uid是否有相应的权限，系统级的platform.xml中进行查找 数字证书，APP签名文件 Linux内核访问权限控制，System，root用户才有权限访问系统文件 虚拟机沙箱隔离，每个APP有与之对应的UID 隐患 123代码漏洞:LaunchAnyWhere,FakeID BugRoot风险安全机制不健全 反编译工具 apktool 1234反编译 apktool.jar d test.apk生成test文件夹重新打包 apktool.jar b test.apk生成重新打包的apk，在dist文件夹中 Dex2jar,jd-gui 123dex2jar.bat classes.dex生成classes.jar文件使用jd-gui查看源码 apk加密 1234567buildTypes &#123; release&#123; minifyEnabled false //以前属性名是runProguard proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), //系统默认 &apos;proguard-rules.pro&apos; // 项目自定义 &#125;&#125; 加固 阿里聚安全 腾讯云应用乐固 360加固保]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Activity)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-Activity%2F</url>
    <content type="text"><![CDATA[Activity，Activity调用栈 onCreate 创建基本元素 初始化资源，或在onPause中释放的资源 onPause/onStop 清除Activity资源，camera，sensor，receivers onDestory 清除线程 activity 在onSaveInstanceState()保存状态到Bundle，在onRestoreInstanceState(),onCreate()恢复状态Bundle，已经默认实项了控件的状态保存 Activity任务栈 栈底元素是整个任务栈发起者 一个任务栈Task,表示若干个Activity集合，可以来自不同的App，一个App的Activity也可以在不同的Task中 LIFO 后进先出 启动模式launchmode standard默认启动模式，每次都会创建新的实例 singleTop栈顶模式，如果栈顶是要启动的Activity，直接引用，如果不是创建新的Activity，例如qq接受多条消息，弹出的消息界面 singleTask单栈模式，要启动的Activity，如果栈中存在该Activity，将其置于栈顶，并将位于上方的Activity销毁，指同一个App中启动它的Activity，如果其他App以singleTask模式启动这个Activity，将会创建新的Activity。但是如果启动的Activity已经在一个任务栈中处于后台，那所在的任务栈会和要启动的Activity一起回到前台，当已经启动的Activity需要按返回键时，就会先返回Activity所在栈的元素应用：将主Activity设置为singleTask，然后在要退出的Activity中启动主Activity，将他之上的Activity全部销毁,重写onNewIntent(),加上finish(),将最后一个主Activity结束 singleInstanse栈中只存在该一个Activity，共享实例，不需要重新创建，类似浏览器，电话 注意：singleTop或singleInstance的Activity A通过startActivityForResult()启动另一个Activity B，直接返回Activity.RESULT_CANCELD ,只能通过Intent绑定数据 Intent Flag Intent.FLAG_ACTIVITY_NEW_TASK 启动的Activity在新的Task中，使用在Service中启动Activity，因为Service没有任务栈 Intent.FLAG_ACTIVITY_SINGLE_TOP 存在直接引用，不存在创建新的 Intent.FLAG_ACTIVITY_CLEAR_TOP 与singleTask相同，存在引用并销毁，不存在创建新的 Intent.FLAG_ACTIVITY_NO_HISTORY 以这种模式启动的Activity C会消失，A-&gt;B-&gt;C-&gt;D,当前Activity栈中为ABD 清空任务栈 clearTaskOnTouch 每次返回该Activity 清除其他Activity，初始化Task，只有一个该Activity finishOnTaskLaunch 返回该Activity时，会被finish alwaysRetainTaskState 保持当前Task状态，不接受任何清理命令]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(SurfaceView)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-SurfaceView%2F</url>
    <content type="text"><![CDATA[SurfaceView View适用于主动刷新，SurfaceView适用于被动刷新，例如频繁刷新 View在主线程中对画面进行刷新，SurfaceView通常会在子线程进行页面刷新 View绘制时没有使用双缓冲机制，SurfaceView在底层机制中实项了双缓冲机制正弦曲线，绘画板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 private void init() &#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setFocusableInTouchMode(true); setKeepScreenOn(true);// mSurfaceHolder.setFormat(PixelFormat.OPAQUE); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPath = new Path(); mDrawPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mDrawPaint.setColor(Color.RED); mDrawPaint.setStyle(Paint.Style.STROKE); mDrawPaint.setStrokeCap(Paint.Cap.ROUND); mDrawPaint.setStrokeWidth(5); mDrawPaint.setStrokeJoin(Paint.Join.ROUND); mDrawPath = new Path(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mPath.moveTo(0, getHeight() / 2); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; Log.e(&quot;surfaceCreated&quot;, Thread.currentThread().getName()); new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDrawPath.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: mDrawPath.lineTo(x, y); break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; @Override public void run() &#123; while (mIsDrawing) &#123; long start = System.currentTimeMillis(); draw(); long end = System.currentTimeMillis(); //100是经验值，取值范围50-100ms if (end - start &lt; 100) &#123; try &#123; Thread.sleep(100 - (end - start)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; x += 1; y = (int) (100 * Math.sin(x * 2 * Math.PI / 180) + 100); mPath.lineTo(x, y); &#125; &#125; private void draw() &#123; try &#123; //获得canvas图像 mCanvas = mSurfaceHolder.lockCanvas(); //surfaceview 背景 mCanvas.drawColor(Color.WHITE); //绘制路径 mCanvas.drawPath(mPath, mPaint); mCanvas.drawPath(mDrawPath, mDrawPaint); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //保证每次内容的提交 if (mCanvas != null) mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Paint Shader)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-Paint-Shader%2F</url>
    <content type="text"><![CDATA[Paint PorterDuffXfermode 两个图层交集区域显示方式,用的最多是DST_IN,SRC_IN显示圆形图片或圆角图片 圆角矩形 123456789101112private void drawRoundRect() &#123; ImageView roundRectIv = findViewById(R.id.roundRectIv); Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); Bitmap mOut = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); PorterDuffXfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); Canvas canvas = new Canvas(mOut); canvas.drawRoundRect(0, 0, mBitmap.getWidth(), mBitmap.getHeight(), 100, 100, mPaint); mPaint.setXfermode(mXfermode); canvas.drawBitmap(mBitmap, 0, 0, mPaint); roundRectIv.setImageBitmap(mOut); &#125; 刮刮卡12345678910111213141516171819202122232425262728293031323334353637383940private void init() &#123; bgBmp = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); fgBmp = Bitmap.createBitmap(bgBmp.getWidth(), bgBmp.getHeight(), Bitmap.Config.ARGB_8888); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //画路径时走透明通道，形成刮刮卡效果 mPaint.setAlpha(0); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeJoin(Paint.Join.ROUND); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(50); mCanvas = new Canvas(fgBmp); mCanvas.drawColor(Color.GRAY); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPath.reset(); mPath.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: mPath.lineTo(x, y); break; &#125; mCanvas.drawPath(mPath, mPaint); invalidate(); return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(bgBmp, 0, 0, null); canvas.drawBitmap(fgBmp, 0, 0, null); &#125; Shader(着色器，渲染器)123CLAMP 拉伸图片最后一个像素，不断重复REPEAT 横向纵向不断重复MIRROR 横向纵向翻转重复 BitmapShader 位图shader 12345678910111213141516171819202122232425圆形图片private void init() &#123; bm = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); //图像填充功能 bitmapShader = new BitmapShader(bm, Shader.TileMode.CLAMP, Shader.TileMode.REPEAT); mPaint = new Paint(); mPaint.setShader(bitmapShader); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mLinearGradient=new LinearGradient(100,300,300,500, Color.RED,Color.YELLOW, Shader.TileMode.CLAMP); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200, 200, 100, mPaint); mPaint.setShader(mLinearGradient); canvas.drawRect(100,300,300,500,mPaint); &#125; LinearGradient 线性shader RadialGradient 光束shader SweepGradient 梯度shader ComposeShader 混合shader 图像倒影 1234567891011121314151617181920212223242526private void init() &#123; mSrcBitmap= BitmapFactory.decodeResource(getResources(), R.mipmap.car3); Matrix matrix=new Matrix(); //实项垂直翻转，(-1,1)实项水平翻转 matrix.setScale(1,-1); mRefBitmap=Bitmap.createBitmap(mSrcBitmap,0,0, mSrcBitmap.getWidth(),mSrcBitmap.getHeight(),matrix,true); mPaint=new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setShader(new LinearGradient(0,mSrcBitmap.getHeight(), 0,mSrcBitmap.getHeight()+mSrcBitmap.getHeight()/4, 0xdd000000,0x33000000, Shader.TileMode.CLAMP)); mXferMode=new PorterDuffXfermode(PorterDuff.Mode.DST_IN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.BLACK); canvas.drawBitmap(mSrcBitmap,0,0,null); canvas.drawBitmap(mRefBitmap,0,mSrcBitmap.getHeight(),null); mPaint.setXfermode(mXferMode); canvas.drawRect(0,mSrcBitmap.getHeight(),mRefBitmap.getWidth(), mSrcBitmap.getHeight()*2,mPaint); mPaint.setXfermode(null); &#125; PathEffect ComposePathEffect 先应用一种路径效果，再这个基础上混合另外一种效果 CornerPathEffect 圆角路径 DashPathEffect 虚线路径 DiscretePathEffect 杂点路径 PathDashPathEffect 设置点的图形路径效果 SumPathEffect 组合两种路径后再应用到图形上 12345678910111213141516171819202122232425262728293031private void init() &#123; mEffects=new PathEffect[7]; mPaint=new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mPath=new Path(); mPath.moveTo(0,0); for (int i = 0; i &lt;=30; i++) &#123; mPath.lineTo(i*35, (float) (Math.random()*100)); &#125; mEffects[0]=null; mEffects[1]=new CornerPathEffect(30); mEffects[2]=new DiscretePathEffect(5,3); mEffects[3]=new DashPathEffect(new float[]&#123;10,20,30,50&#125;,0); Path path=new Path(); path.addRect(0,0,10,10, Path.Direction.CCW); mEffects[4]=new PathDashPathEffect(path,12,0, PathDashPathEffect.Style.ROTATE); mEffects[5]=new ComposePathEffect(mEffects[3],mEffects[1]); mEffects[6]=new SumPathEffect(mEffects[3],mEffects[1]); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); for (PathEffect mEffect : mEffects) &#123; mPaint.setPathEffect(mEffect); canvas.drawPath(mPath,mPaint); canvas.translate(0,200); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(View)]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid-Notes-View%2F</url>
    <content type="text"><![CDATA[Android 绘图机制处理 系统屏幕密度，密度值，分辨率对应关系 1ldpi=120(240*320),mdpi=160(320*480)，hdpi=240(480*800),xhdpi=320(720*1280),xxhdpi=480(1080*1980) 独立像素密度(密度无关像素 (dp)在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度 或位置) 1ldpi:mdpi:hdpi:xhdpi:xxhdpi=120:160:240:320:480=0.75px:1px:1.5px:2px:3px=3:4:6:8:12 单位转换 12345678910scale=getResources().getDisplayMetrics().density;px2dp: pxValue/scale+0.5f;dp2px: dpValue*scale+0.5f;fontScale=getResources().getDisplayMetrics().scaledDensity;px2sp: pxValue/fontScale+0.5f;sp2px: pxValue*fontScale+0.5f;TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,dp,getResource().getDisplayMetrics()); 2D绘图 setAntiAlias()//画笔锯齿 setColor()//画笔颜色 setARGB() setAlpha() setTextSize() setStyle()//空心，实心 setStrokerWidth()//边框宽度1234567891011drawPointdrawLinedrawLinesdrawRectdrawRoundRectdrawCircledrawArc 绘制弧形，使用中心或实心，空心drawOval 绘制椭圆drawText 绘制文本drawPosText 指定位置绘制文本drawPath 绘制路径 XML Bitmap 12&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@mipmap/car1&quot; /&gt; Shape 123456789101112131415&lt;shape android:shape=&quot;rectangle|oval|line|ring&quot;&gt;&lt;!--配合ImageView scaleType--&gt;&lt;size android:width=&quot;12dp&quot; android:height=&quot;12dp&quot; /&gt;&lt;!--虚线宽度，间隔--&gt;&lt;stroke android:width=&quot;20dp&quot; android:color=&quot;@color/colorAccent&quot; android:dashGap=&quot;2dp&quot; android:dashWidth=&quot;6dp&quot; /&gt;&lt;/shape&gt; Layer 1234&lt;layer-list&lt;item android:drawable=&quot;@mipmap/car1&quot;/&gt;&lt;item android:drawable=&quot;@mipmap/car2&quot;/&gt;&lt;/layer-list&gt; Selector 1234567891011&lt;item android:drawable=&quot;@android:drawable/btn_default&quot; /&gt; &lt;!--没有焦点时--&gt; &lt;item android:state_window_focused=&quot;false&quot; /&gt; &lt;!--非触摸单击时--&gt; &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;true&quot; /&gt; &lt;!--触摸模式下单击时--&gt; &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; /&gt; &lt;!--选中时--&gt; &lt;item android:state_selected=&quot;true&quot; /&gt; &lt;!--获得焦点时--&gt; &lt;item android:state_focused=&quot;true&quot; /&gt; 绘图技巧 Canvas 123456789//保存之前绘制图像，后续绘制在新的图层canvas.save()//save之前的图像和之后的图像合并canvas.restore() //坐标系平移，原点(0,0)移动到(x,y)canvas.translate()//坐标系旋转canvas.rotate() Board 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.RED); mPaint.setStrokeWidth(2);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); mHeight = getHeight();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mWidth / 2, mHeight / 2, mWidth / 2, mPaint); for (int i = 0; i &lt; 24; i++) &#123; if (i == 0 || i == 6 || i == 12 | i == 18) &#123; mPaint.setStrokeWidth(5); mPaint.setTextSize(30); canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2, mWidth / 2, mHeight / 2 - mWidth / 2 + 60, mPaint); canvas.drawText(String.valueOf(i), mWidth / 2, mHeight / 2 - mWidth / 2 + 90, mPaint); &#125; else &#123; mPaint.setStrokeWidth(3); mPaint.setTextSize(16); canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2, mWidth / 2, mHeight / 2 - mWidth / 2 + 30, mPaint); canvas.drawText(String.valueOf(i), mWidth / 2, mHeight / 2 - mWidth / 2 + 60, mPaint); &#125; //旋转画布简化角度,坐标运算 canvas.rotate(15, mWidth / 2, mHeight / 2); &#125; canvas.save(); mPaint.setColor(Color.CYAN); mPaint.setStrokeWidth(10); canvas.translate(mWidth / 2, mHeight / 2); canvas.drawLine(0, 0, 100, 100, mPaint); canvas.drawLine(0, 0, 100, 200, mPaint); canvas.restore();&#125; layer图层 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.BLUE); canvas.drawCircle(mWidth / 2, mHeight / 2, 50, mPaint); canvas.saveLayerAlpha(0, 0, mWidth, mHeight, 127, ALL_SAVE_FLAG); mPaint.setColor(Color.RED); canvas.drawCircle(mWidth / 2 + 50, mHeight / 2 + 50, 50, mPaint); canvas.restore();&#125; 色彩特效 图片的数据结构常使用位图Bitmap,由点阵(像素点矩阵)和颜色值(ARGB)组成 色彩处理中包含色调，饱和度，亮度，使用ColorMatrix(4*5颜色矩阵) 1234567891011121314151617181920212223242526272829303132333435[a, b, c, d, e,f, g, h, i, j,k, l, m, n, o,p, q, r, s, t ]在Android中以一维数组存储 float[] mArray = new float[20]R = a*R + b*G + c*B + d*A + e;G = f*R + g*G + h*B + i*A + j;B = k*R + l*G + m*B + n*A + o;A = p*R + q*G + r*B + s*A + t;初始矩阵不会对颜色改变A=[1,0,0,0,00,1,0,0,00,0,1,0,00,0,0,1,0]色调setRotate(int axis,floate degrees)axis=0 the RED coloraxis=1 the GREEN coloraxis=2 the BLUE color饱和度，为0时是灰度图像setSaturation(float sat)亮度setScale(float rScale, float gScale, float bScale,float aScale)矩阵乘法运算postConcat(ColorMatrix postmatrix)setConcat(postmatrix, this)imageMatrix.postContact(hueMatrix)imageMatrix.postContact(saturationMatrix)imageMatrix.postContact(lumMatrix) 滑动seekbar，改变颜色混合效果 123456789101112131415161718192021222324252627282930313233343536373839404142public static Bitmap handleImageEffect(Bitmap bm, float hue, float saturation, float lum) &#123; Bitmap bmp = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(); ColorMatrix hueMatrix = new ColorMatrix(); hueMatrix.setRotate(0, hue); hueMatrix.setRotate(1, hue); hueMatrix.setRotate(2, hue); ColorMatrix saturationMatrix = new ColorMatrix(); saturationMatrix.setSaturation(saturation); ColorMatrix lumMatrix = new ColorMatrix(); lumMatrix.setScale(lum, lum, lum, 1); ColorMatrix imageMatrix = new ColorMatrix(); imageMatrix.postConcat(hueMatrix); imageMatrix.postConcat(saturationMatrix); imageMatrix.postConcat(lumMatrix); paint.setColorFilter(new ColorMatrixColorFilter(imageMatrix)); canvas.drawBitmap(bm, 0, 0, paint); return bmp; &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; switch (seekBar.getId()) &#123; case R.id.hueSeekBar: mHue = (progress - 50) * 1.0f / 50 * 180; break; case R.id.saturationSeekBar: mSaturation = progress * 1.0f / 50; break; case R.id.lumSeekBar: mLum = progress * 1.0f / 50; break; &#125; filterImage.setImageBitmap(ColorMatrixUtil.handleImageEffect(bm, mHue, mSaturation, mLum)); &#125; Android不允许直接修改原图，创建同大小的位图，并将原图绘制到该Bitmap 1234Bitmap bmp=Bitmap.createBitmap(bm.getWidth(),bm.getHeight(),Bitmap.Config.ARGB_8888);Canvas canvas=new Canvas(bmp);paint.setColorFilter(new ColorMatrixColorFilter(matrix));canvas.drawBitmap(bm,0,0,paint); ColorMatrix 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void addEts() &#123; gridLayout.post(new Runnable() &#123; int mEtHeight; int mEtWidth; @Override public void run() &#123; mEtHeight = gridLayout.getWidth() / 4; mEtWidth = gridLayout.getWidth() / 5; for (int i = 0; i &lt; 20; i++) &#123; EditText editText = new EditText(getBaseContext()); gridLayout.addView(editText, mEtWidth, mEtHeight); mEts[i] = editText; &#125; initMatrix(); &#125; &#125;); &#125; private void initMatrix() &#123; for (int i = 0; i &lt; mEts.length; i++) &#123; if (i % 6 == 0) &#123; mEts[i].setText(&quot;1&quot;); &#125; else &#123; mEts[i].setText(&quot;0&quot;); &#125; &#125; &#125; private void getMatrix() &#123; for (int i = 0; i &lt; mEts.length; i++) &#123; mColorMatrix[i] = Float.valueOf(mEts[i].getText().toString()); &#125; &#125; private void setImageMatrix() &#123; Bitmap bmp = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(); ColorMatrix colorMatrix = new ColorMatrix(mColorMatrix); paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bm, 0, 0, paint); filterImage.setImageBitmap(bmp); &#125; 图像反转 获取图像像素值,三种像素点处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void getPixels() &#123; ImageView pixelImage1 = findViewById(R.id.pixelImage1); ImageView pixelImage2 = findViewById(R.id.pixelImage2); ImageView pixelImage3 = findViewById(R.id.pixelImage3); bm = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); int[] pixels = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels1 = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels2 = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels3 = new int[bm.getWidth() * bm.getHeight()]; bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); Bitmap bmp1 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Bitmap bmp2 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Bitmap bmp3 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); for (int i = 0; i &lt; pixels.length; i++) &#123; int color = pixels[i]; int r = Color.red(color); int g = Color.green(color); int b = Color.blue(color); int a = Color.alpha(color); //老照片 int r1 = (int) (0.393 * r + 0.769 * g + 0.189 * b); int g1 = (int) (0.349 * r + 0.686 * g + 0.168 * b); int b1 = (int) (0.272 * r + 0.534 * g + 0.131 * b); newPixels1[i] = Color.rgb(r1, g1, b1); //底片处理 int r2 = 255 - r; int g2 = 255 - g; int b2 = 255 - b; if (r &gt; 255) &#123; r = 255; &#125; else if (r &lt; 0) &#123; r = 0; &#125; if (g &gt; 255) &#123; g = 255; &#125; else if (g &lt; 0) &#123; g = 0; &#125; if (b &gt; 255) &#123; b = 255; &#125; else if (b &lt; 0) &#123; b = 0; &#125; newPixels2[i] = Color.argb(a, r2, g2, b2); //浮雕 int rB = 0; int gB = 0; int bB = 0; if (i + 1 &lt; pixels.length) &#123; int colorB = pixels[i + 1]; rB = Color.red(colorB); gB = Color.green(colorB); bB = Color.blue(colorB); rB = r - rB + 127; gB = g - gB + 127; bB = b - bB + 127; if (rB &gt; 255) &#123; rB = 255; &#125; if (gB &gt; 255) &#123; gB = 255; &#125; if (bB &gt; 255) &#123; bB = 255; &#125; &#125; newPixels3[i] = Color.rgb(rB, gB, bB); &#125; bmp1.setPixels(newPixels1, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); bmp2.setPixels(newPixels2, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); bmp3.setPixels(newPixels3, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); pixelImage1.setImageBitmap(bmp1); pixelImage2.setImageBitmap(bmp2); pixelImage3.setImageBitmap(bmp3); &#125; 图像变换矩阵初始矩阵 123[1 0 0 0 1 0 0 0 1] 图像处理基本变换 Translate 1234567p(x0,y0)-&gt;p(x,y)x=Δx+x0y=Δy+y0变换矩阵[1 0 Δx 0 1 Δy 0 0 1 ] Rotate 以坐标原点为中心旋转 Scale 每个点的坐标等比例缩放 Skew 保持所有点的x或y轴坐标不变，对应的y或x坐标等比例平移，有水平错切和垂直错切 123456matrix.setRotate()matrix.setTranslate()matrix.setScale()matrix.setSkew()set()会重置pre().post()前乘后乘对矩阵混合使用 drawBitmapMesh()像素块 12改变图像坐标值重新定位每一个图像块drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight,@NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset,@Nullable Paint paint) 旗帜FlagView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public class FlagView extends View &#123; private float[] orig, verts; int HEIGHT = 100, WIDTH = 100; //振幅 private float A = 20; private Bitmap bitmap; private float k; public FlagView(Context context) &#123; this(context, null); &#125; public FlagView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public FlagView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); int bitmapWidth = bitmap.getWidth(); int bitmapHeight = bitmap.getHeight(); int index = 0; orig = new float[bitmapHeight * bitmapWidth]; verts = new float[bitmapHeight * bitmapWidth]; for (int y = 0; y &lt;= HEIGHT; y++) &#123; float fy = bitmapHeight * y / HEIGHT; for (int x = 0; x &lt;= WIDTH; x++) &#123; float fx = bitmapWidth * x / WIDTH; orig[index * 2 + 0] = verts[index * 2 + 0] = fx; //+100 避免被遮挡 orig[index * 2 + 1] = verts[index * 2 + 1] = fy + 100; index += 1; &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(); k += 0.1f; canvas.drawBitmapMesh(bitmap, WIDTH, HEIGHT, verts, 0, null, 0, null); invalidate(); &#125; private void flagWave() &#123; for (int j = 0; j &lt;= HEIGHT; j++) &#123; for (int i = 0; i &lt;= WIDTH; i++) &#123; verts[(j * (WIDTH + 1) + i) * 2 + 0] += 0; //图像动起来，纵坐标周期性变化 float offsetY = (float) Math.sin((float) i / WIDTH * 2 * Math.PI + Math.PI * k); verts[(j * (WIDTH + 1) + i) * 2 + 1] = orig[(j * WIDTH + i) * 2 + 1] + offsetY * A; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes (ListView Scroller)]]></title>
    <url>%2F2018%2F03%2F02%2FAndroid-Notes-ListView-Scroller%2F</url>
    <content type="text"><![CDATA[ListView使用技巧 优化技巧 ViewHolder-ListView 视图缓存机制 设置分割线divider=”@null”透明 取消点击效果，listSelector smoothScrollBy/ToPosition() 处理空ListView,listView.setEmptyView(ImageView) 滑动监听，onTouchListener,onScrollListener,GestureDetector手势识别,VelocityTracker滑动速度检测 拓展 滚动到顶部，底部时有个弹性距离可以继续滑动，松开后回弹 123456789private void init()&#123; mMaxOverDistance= (int) (getResources().getDisplayMetrics().density*mMaxOverDistance);&#125;@Overrideprotected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) &#123; Log.e(&quot;overscroll&quot;,&quot;by &quot;+mMaxOverDistance); return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxOverDistance, isTouchEvent);&#125; 聊天ListView getItemViewType(position)-&gt; mData.get(position).getType() getViewTypeCount()-&gt;2 getView()区分type，实例化不同布局添加内容 listview选中未选中状态: 在getView()中判断，点击选中的item的position和当前position是否相同，添加不同的布局 Android Scroll滑动效果是触摸事件不断改变View的坐标，移动位置，来达到滑动效果 触摸事件类型 12345678910111213141516171819202122232425 //单点触摸按下 public static final int ACTION_DOWN= 0; //单点触摸离开 public static final int ACTION_UP= 1; //触摸点移动 public static final int ACTION_MOVE= 2; //触摸动作取消 public static final int ACTION_CANCEL= 3; //触摸动作超出边界 public static final int ACTION_OUTSIDE= 4; //多点触摸按下 public static final int ACTION_POINTER_DOWN= 5; //多点触摸离开 public static final int ACTION_POINTER_UP= 6; int x = (int) event.getX();int y = (int) event.getY();switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: break; case MotionEvent.ACTION_MOVE: break;&#125; 实项滑动的七种方法 layout() 123456789101112131415161718192021222324252627282930313233343536相对于视图坐标系的获取坐标getX,getY,而lastX,lastY不需要重新设置坐标,因为相对于视图坐标，点击屏幕获取到的坐标会重新设置对于Android屏幕坐标系，getRawX,getRawY,lastRawX,lastRawY需要重新设置，获取准确的偏移量，第一次坐标位置getRawX,getRawY在(10,10),在移动到(20,20)，偏移量为10，此时不重新设置，下个点是(50,50),偏移量是50-10=40,而实际正确的偏移量为50-20=30@Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int rx = (int) event.getRawX(); int ry = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; lastrX = rx; lastrY = ry; break; case MotionEvent.ACTION_MOVE: int dx = x - lastX; int dy = y - lastY; int rdx = rx - lastrX; int rdy = ry - lastrY; Log.e(&quot;drag&quot;, &quot;x=&quot; + x + &quot; y=&quot; + y + &quot; lastX=&quot; + lastX + &quot; lastY=&quot; + lastY); Log.e(&quot;drag&quot;, &quot;rx=&quot; + rx + &quot; ry=&quot; + ry + &quot; lastrX=&quot; + lastrX + &quot; lastrY=&quot; + lastrY); Log.e(&quot;drag&quot;, &quot;dx=&quot; + dx + &quot; dy=&quot; + dy + &quot; rdx=&quot; + rdx + &quot; rdy=&quot; + rdy); layout(getLeft() + dx, getTop() + dy, getRight() + dx, getBottom() + dy);// lastrX = x;// lastrY = y; break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; offsetLeftAndrRight(),offsetTopAndBottom() 12offsetLeftAndRight(dx);offsetTopAndBottom(dy); LayoutParams(),ViewGroup.MarginLayoutParams 123456789FrameLayout.LayoutParams layoutParams= (FrameLayout.LayoutParams) getLayoutParams();layoutParams.leftMargin=getLeft()+dx;layoutParams.topMargin=getTop()+dy;setLayoutParams(layoutParams);ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();layoutParams.leftMargin = getLeft() + dx;layoutParams.topMargin = getTop() + dy;setLayoutParams(layoutParams); ScrollTo(x,y)/ScrollBy(dx,dy) 1234567891011121314151617181920212223 ViewGroup 移动的是子View View移动的是内容 //移动的是屏幕下方画布，会造成内容向相反方向移动 //scrollBy(dx,dy); //所以移动父视图，并且值为负，相反方向scrollby才有正确的效果case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; if (!isScroll) &#123; lastrX = rx; lastrY = ry; &#125; break;case MotionEvent.ACTION_MOVE: int dx = x - lastX; int dy = y - lastY; //移动的是屏幕下方画布，会造成内容向相反方向移动 // scrollBy(dx,dy); //((View) getParent()).scrollBy(-dx, -dy); ((View) getParent()).scrollTo(-(int) event.getRawX() + lastrX, -(int) event.getRawY() + lastrY); isScroll = true; break; Scroller 实现平移滑动 初始化Scroller 1mScroller=new Scroller(context); 重写computeScroll()模拟滑动 1234567891011 @Override public void computeScroll() &#123; super.computeScroll(); //判断Scroll是否执行完毕，true 没有执行完 if(mScroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); //只能通过invalidate()—&gt;draw()-&gt;computeScroll()间接调用computeScroll()， //结束后computeScrollOffset()返回false，中断循环 postInvalidate(); &#125;&#125; startScroll 开始模拟滑动 123456789101112131415161718192021222324252627@Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int rx = (int) event.getRawX(); int ry = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; lastRx = rx; lastRy = ry; break; case MotionEvent.ACTION_MOVE: ((View) getParent()).scrollTo(-rx + lastRx, -ry + lastRy); break; case MotionEvent.ACTION_UP: View parent = (View) getParent(); //模拟滑动，起始坐标和偏移量，滑动偏移为滑动距离的负数，相反方向滑动 mScroller.startScroll(parent.getScrollX(), parent.getScrollY(), -parent.getScrollX(), -parent.getScrollY()); //通知重绘 invalidate(); break; &#125; return true; &#125; ViewDragHelper实项Drawlayout菜单侧滑 youtubelayout 回调 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; /**重写tryCaptureView,何时开始检测触摸事件， * 当前触摸的是MainView时开始检测*/ @Override public boolean tryCaptureView(View child, int pointerId) &#123; return mMainView == child; &#125; /**水平垂直方向上的滑动,默认返回0，不滑动*/ @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123;// return super.clampViewPositionHorizontal(child, left, dx); return left; &#125; @Override public int clampViewPositionVertical(View child, int top, int dy) &#123;// return super.clampViewPositionVertical(child, top, dy); return top; &#125; /**拖动结束后调用，自动滑动打开或关闭菜单*/ @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); if (mMainView.getTop() &gt; mHeight / 2) &#123; mViewDragHelper.smoothSlideViewTo(mMainView, 0, (int) (mHeight * 1.2f)); &#125; else &#123; if (mMainView.getLeft() &lt; mWidth / 2) &#123; //关闭菜单 mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0); &#125; else &#123; mViewDragHelper.smoothSlideViewTo(mMainView, (int) (mWidth * 1.2f), 0); &#125; &#125; ViewCompat.postInvalidateOnAnimation(ViewDragHelperView.this); &#125; /**更改scale进行缩放*/ @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); &#125; /**状态改变*/ @Override public void onViewDragStateChanged(int state) &#123; super.onViewDragStateChanged(state); &#125; /**触摸后回调*/ @Override public void onViewCaptured(View capturedChild, int activePointerId) &#123; super.onViewCaptured(capturedChild, activePointerId); &#125; &#125;; 获取宽度 123456@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = mMenuView.getMeasuredWidth(); mHeight = mMenuView.getMeasuredHeight(); &#125; 获取MenuView,MainView 123456@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mMenuView = getChildAt(0); mMainView = getChildAt(1);&#125; 触摸事件拦截，并传递给VieDragHelper 12345678910111213141516/** * 触摸事件传递给ViewDragHelper,必须写 */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mViewDragHelper.processTouchEvent(event); return true;&#125;/** * 重写事件拦截方法，把事件传递给ViewDragHelper */@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125; 重写computeScroll() 12345678910/** * 平滑移动 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mViewDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker 编译Android源码]]></title>
    <url>%2F2018%2F02%2F26%2FDocker-%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Windows 安装Docker Cannot install packages inside docker Ubuntu image 1234567891011It is because there is no package cache in the image, you need to run:apt-get -qq updatebefore installing packages, and if your command is in a Dockerfile, you&apos;ll then need:apt-get -qq -y install curlAlways combine RUN apt-get update with apt-get install in the same RUN statement, for exampleRUN apt-get update &amp;&amp; apt-get install -y package-bar 参考使用Docker编译Android系统源码 Ubuntu14.10 编译 Android5.0 源码 更换系统镜像源 apt-get install wget wget 网址而要让档案自动储存到指令的目录下，则需要借用-P这个参数，可以使用以下的指令 wget -P 目录 网址举例来说，如果你要放到/root底下，你可以打下列的指令：wget -P /root 网址 安装配置openjdk-7-jreubuntu 16 无法安装jdk7解决办法 12345678910111213sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update sudo apt-get install openjdk-7-jdkvim/gedit ~/.bashrcexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/bin/tools.jar:$JRE_HOME/binexport ANDROID_JAVA_HOME=$JAVA_HOMEexport USE_CCACHE=1source ~/.bashrc 安装其他工具 12345678910111213141516dpkg --print-architecture # 若支持，输出 amd64dpkg --print-foreign-architectures # 若支持，输出 i386//手动开启支持dpkg --add-architecture i386apt-get updatesudo apt-get install gcc-multilib g++-multilib build-essentialsudo apt-get install git-core gnupg bison flex gperf pngcrush bc zip curl lzopsudo apt-get install schedtool libxml2 libxml2-utils xsltproc squashfs-toolssudo apt-get install libesd0-dev libsdl1.2-dev libwxgtk2.8-dev libswitch-perlsudo apt-get install libssl1.0.0 libssl-dev lib32readline-gplv2-dev libncurses5-devcd /AOSPexport USE_CCACHE=1export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccacheprebuilts/misc/linux-x86/ccache/ccache -M 50G windows 上创建/androidsource git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git输入命令，切换到manifest目录 cd manifest Git tag 列出android各个分支版本下载android-android-5.1.1_r9git checkout android-5.1.1_r9 运行 python download-src.py 1234567891011121314151617181920212223242526272829import xml.dom.minidom import os from subprocess import call #downloaded source path rootdir = &quot;E:/androidsource&quot; #git program path git = &quot;D:/Git/bin/git.exe&quot;dom = xml.dom.minidom.parse(&quot;E:/androidsource/manifest/default.xml&quot;) root = dom.documentElementprefix = git + &quot; clone https://aosp.tuna.tsinghua.edu.cn/&quot; suffix = &quot;.git&quot; if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName(&quot;project&quot;): os.chdir(rootdir) d = node.getAttribute(&quot;path&quot;) last = d.rfind(&quot;/&quot;) if last != -1: d = rootdir + &quot;/&quot; + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute(&quot;name&quot;) + suffix call(cmd) 出现 curl: (22) The requested URL returned error: 404 Not Found Server does not provide clone.bundle; ignoring. 怎么办？无视即可 下载repo 123456789101112131415161718192021mkdir ~/binPATH=~/bin:$PATHcurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo(或者下面的地址)curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repochmod a+x reporepo的运行过程中会尝试访问官方的git源更新自己，如果想可以使用[tuna的镜像](https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/)源进行更新，可以将如下内容复制到你的~/.bashrc里export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;并重启终端模拟器cd /AOSP初始化同步reporepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-5.1.1_r9repo sync -f -j4AOSP 未下完成是不显示文件，.repo是隐藏文件夹，ctrl+h显示有问题时删除缓存文件rm -rf * -R 设置repo环境变量 123vim ~/.bashrcexport PATH=~/bin:$PATHsource ~/.bashrc Ubuntu 下载源码 start a shell session in a running container 12345docker exec -it 98e0b4f60ec3 bash$ sudo docker attach 665b4a1e17b6 #by ID or$ sudo docker attach loving_heisenberg #by Name$ root@665b4a1e17b6:/# Windows mount shared folder to Ubuntu 12345678910111213141516171819202122In Window Host:-1. Create a folder &quot;aosp&quot; -- Window2. Right Click on &quot;nandan&quot; -- Properties -- sharing -- Advance Sharing3. Check option &quot;share this folder&quot; - permission -remove Group or Username &quot;Everyone&quot;.4. Add User - select your user account from List5. Check Full Control,Read,Change6. Applu- Ok - Exit7. open cmd - ipconfig - copy ipv4 for Wireless lan Adapter incase if you are using WIFI----------------In Ubuntu VM :-1. Open terminal.. 2. become root $sudo su-3. apt-cache search cifs4. if cifs utils not present then install $ sudo apt-get install cifs-utils5. df -h6. $sudo mkdir /media/test7. $sudo mount.cifs-o username= window_username //window_ip_address/window_share_folder_name /media/test复制win共享文件夹到Ubuntucp -r aosp(win shared folder) AOSP Android系统源代码的下载与编译 初始化源码所需环境变量和参数 1source build/envsetup.sh lunch 命令选择编译目标 make -j16 (nproc 查看cpus)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 c++]]></title>
    <url>%2F2018%2F02%2F26%2F%E7%AE%97%E6%B3%95-c%2F</url>
    <content type="text"><![CDATA[排序算法]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes (System ADB UI)]]></title>
    <url>%2F2018%2F02%2F25%2FAndroid-Notes%2F</url>
    <content type="text"><![CDATA[Android系统架构 Android系统分四层：Linux内核层，库和运行时，Framework层和应用层。 Linux包括硬件驱动，进程管理，安全系统 Dalvik虚拟机，运行时编译；ART虚拟机安装时编译 Framework ActivityManager BackupManager Bluetooth ContentProviders LocationManger Map libraries MediaPlayer NotificationManager PackageManager ResourceManager SearchManager SharedPreference TelephoneManager WidgetProvider WindowManager ViewSystem XMPPService 标准库 Apache HTTP OpenGL ES Open SSL SQLite Webkit ICU Android NDK/SDK APP(解压后包含内容中有) AndroidManifeset Dalvik Classes Resource bundle NDK APP中包含JNI lib App组件 Activity BroardCastReceiver ContentProvider Service Context Application Context(应用启动时创建，整个生命周期) Activity Context Service Context Android 源代码目录与系统目录 Android源代码目录 Makefile (自动化编译，定制规则) bionic (bionic C库) bootable (启动引导相关代码) build (系统编译规则等基础开发包配置) cts (Google兼容性测试标准) dalvik (dalvik虚拟机) development (应用程序开发) external (开源模块) frameworks (框架) hardware (硬件适配层HAL代码) out (编译完成后代码输出目录) packages (应用程序包) prebuilt (x86 arm 架构下预编译资源) sdk system (底层文件系统库，应用及组件) vendor (厂商定制代码) Android 系统目录 (ADB ls命令查看系统目录) /system/app/ 系统app /system/bin/ Linux自带组件 /system/build.prop/ 系统属性信息 /system/fonts/ 字体 /system/framework/ 核心文件，框架层 /system/lib/ .so文件 /system/media/ 音频，闹钟，短信，来电等铃声 /system/usr/ 用户配置文件，键盘布局，共享，时区文件 /data/app/ 安装或升级的app /data/data/ App数据文件，数据库等信息 /data/system/ 系统信息 /data/misc/ WIFI，蓝牙，签名，VPN等信息 Android 开发工具 SDK镜像地址 android-studio Genymotion 安装arm架构Genymotion-ARM-Translation Android Debug ADB Command (SDK platform-tools) adb shell ls|grep “data” / cd data android list target 显示系统Android平台 id:1 or android-19 adb install -r a.apk 重新安装保留数据，安装位置/data/local/tmp/a.apk adb push a.apk /system/app 文件写入存储系统，有权限时可以安装系统应用 adb push /system/temp/ c:\Desktop 从手机获取文件 adb shell -&gt; logcat|grep “abc” 查看log adb remount(重新挂载系统分区，使系统分区重新可写) -&gt; adb shell -&gt; cd system/app -&gt; rm a.apk adb shell df 查看系统盘符 adb shell pm list packages -f 输出所有安装应用 adb shell input keyevent 3 模拟按键输入 keycode adb shell input touchscreen swipe 18 655 18 500 模拟滑动输入 adb shell dumpsys activity activities|grep “tencent” 列出activity 运行状态，过滤”tencent” pm list packages -f 列出所有package adb shell am start -n com.qiyi.video/org.qiyi.android.video.MainActivity 启动一个Activity adb shell screenrecord /sdcard/a.mp4 录制屏幕 adb reboot 重启 adb 命令来源 /frameworks/base/cmds/ /system/core/toolbox/ Android 自定义控件 控件架构 ContentView id为content的FrameLayout, onCreate()方法中调用setContentView()后ActivityManagerService会回调onResume()，此时系统才会把DecorView添加到PhoneWindow中，显示并完成绘制 View的测量 onMeasure() MeasureSpec 32位int值，高2位为测量的模式，低30位为测量的大小 EXACTLY 精确值模式，具体数值 AT_MOST 最大值模式，尺寸不超过父控件允许的最大尺寸 UNSPECIFIED 不指定，自定义view时使用,如果View要支持wrap_content,重写onMeasure()指定wrap_content时的大小 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 123456789101112131415161718/** * 宽高值自定义，在wrap_content时如果没有指定大小就会默认填充整个父布局 */private int measureWidth(int measureSpec)&#123; int result=0; int specMode=MeasureSpec.getMoode(measureSpec); int specSize=MeasureSpec.getSize(measureSpec); if(specMode=MeasureSpec.EXACTLY)&#123; result=specSize; &#125;else&#123; result=200; if(specMode=MeasureSpec.AT_MOST)&#123; result=Math.min(result,specSize) &#125; &#125; return result;&#125; View的绘制 重写onDraw(Canvas canvas) Canvas 画板1234567canvas.drawBitmap(bitmap1,0,0,null);canvas.drawBitmap(bitmap2,0,0,null);装载画布Canvas mCanvas=new Canvas(bitmap2);mCanvas.drawXXX刷新view的时候，bitmap2发生改变，没有把图形直接绘制在canvas,而是通过改变bitmap2绘制复杂图形，绘制多个拆分的小图形单元 ViewGroup的测量在wrap_content时遍历子View的大小，决定自己的大小，其他模式下通过具体的指定值设置大小。遍历子View，调用子View的Measure方法获得每一个子View 的测量结果，然后遍历子View进行布局Layout,重写onLayout()控制子View显示位置的逻辑，如果支持wrap_content需要重写onMeasure() ViewGroup的绘制 绘制背景颜色以及遍历子View的绘制 自定义View比较重要的回调方法 onFinishInflate() onSizeChanged() onMeasure() onLayout() onDraw() onTouchEvent() 对原生控件扩展 改变绘制顺序，需要改变画布位置状态时，先保存状态，等改变后，再恢复 12345....canvas.save();canvas.translate(10,0);super.onDraw(canvas);canvas.restore(); LinearGradient,Matrix实项文字闪动效果，onSizeChanged()中初始化，根据宽度设置LinearGradient渐变渲染器 1234567891011121314151617181920212223242526protected void onSizeChanged(int w,int h,int oldw,int oldh)&#123; super.onSizeChanged(w,h,oldw,oldh); if(mViewWidth==0)&#123; mViewWidth=getMeasureWidth(); if(mViewWidth&gt;0)&#123; //获取Paint,设置LinearGradient mPaint=getPaint(); mLinearGradient=new LinearGradient(0,0,mViewWidth,0,new int[] &#123;Color.BLUE,Color.RED&#125;,null,Shader.TitleMode.CLAMP); //设置着色器 mPaint.setShader(mLinearGradient) //平移变换矩阵 mGradientMatrix=new Matrix(); &#125; &#125; &#125;public void onDraw(Canvas canvas)&#123; if(mGradientMatrix!=null)&#123; mTranslate+=mViewWidth/5; if(mTranslate&gt;2*mViewWidth)&#123; mTranslate=-mViewWidth; &#125; mGradientMatrix.setTranslate(mTranslate,0); mLinearGradient.setLocalMatrix(mGradientMatrix); postInvalidateDelayed(100); &#125;&#125; 复合控件继承ViewGroup 定义属性 res/value/attrs.xml 123456789101112&lt;declare-styleable name=&quot;V&quot;&gt; &lt;attr name=&quot;title|size|background&quot; format=&quot;string|dimension| reference|color&quot;/&gt;&lt;/declare-styleable&gt;//获取TypedArray,存储了属性值TypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.V);ta.getColor();ta.getString();ta.getDrawable();ta.getDimension();//资源回收ta.recycle(); 组合控件 12345678mBtn1=new Button();mBtn2=new Button();mTextView=new TextView();mParams=new LayoutParams();mParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,true);addView(mBtn1,mParams);addView(mBtn2,mParams);addView(mTextView,mParams); 定义接口,添加事件 public method include layout 重写View 比例图 中间圆形加中心文字，外圈一定比例的圆弧 length 正方形边长 1234567891011- 圆 mCircle=length/2；mRadius=length/4; drawCirle()- 圆弧//所处的矩形框mRect=new Rect(0.1*length,0.1*length,0.9*length,0.9*length);drawArc(mRect,270,mSweepAngle,false,mArcPaint);- 文字drawText();setSweepValue(100); 音频条形图 onSizeChanged()设置渐变色 onDraw() 绘制多个小矩形 postInvalidateDelayed(300) 123456789101112131415161718192021222324252627282930@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); Log.e(&quot;Audio&quot;, &quot;mWidth=&quot; + mWidth + &quot; w=&quot; + w + &quot; h=&quot; + h + &quot; oldw=&quot; + oldw + &quot; oldh=&quot; + oldh); mRectHeight = getHeight(); mRectWidth = (int) (mWidth * 0.6 / mCount); mLinearGradient = new LinearGradient(0, 0, mRectWidth, mRectHeight, Color.YELLOW, Color.RED, Shader.TileMode.CLAMP); mMatrix = new Matrix(); mPaint.setShader(mLinearGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mTranslate += mRectWidth / 5; if (mTranslate &gt; 2 * mRectWidth) &#123; mTranslate = -mRectWidth; &#125; mMatrix.setTranslate(mTranslate, 0); mLinearGradient.setLocalMatrix(mMatrix); for (int i = 0; i &lt; mCount; i++) &#123; mCurrentHeight = (float) (mRectHeight * Math.random()); canvas.drawRect((float) (mWidth * 0.2 + offset + mRectWidth * i), mCurrentHeight, (float) (mWidth * 0.2 + mRectWidth * (i + 1)), mRectHeight, mPaint); &#125; postInvalidateDelayed(300);&#125; 自定义ViewGroup 重写onMeasure() onLayout() onTouchEvent() 自定义ScrollView，滑动后回位到item的起始位置 遍历的方式通知子View对自身测量 1234567891011121314private void init() &#123; mScroller = new OverScroller(getContext()); mScreenHeight = getResources().getDisplayMetrics().heightPixels; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int count=getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child=getChildAt(i); measureChild(child,widthMeasureSpec,heightMeasureSpec); &#125; &#125; 对子View进行位置放置 123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int screenHeight = getResources().getDisplayMetrics().heightPixels; //获取整个ViewGroup高度 MarginLayoutParams layoutParams = (MarginLayoutParams) getLayoutParams(); layoutParams.height = childCount * screenHeight; setLayoutParams(layoutParams); for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() != View.GONE) &#123; child.layout(l, screenHeight * i, r, screenHeight * (i + 1)); &#125; &#125;&#125; 在onTouchEvent()中添加滑动事件，使用scrollBy() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mLastY = event.getY(); //起点 mStart = getScrollY(); break; case MotionEvent.ACTION_MOVE: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; float dy = mLastY - event.getY(); Log.d(&quot;Scroll&quot;, &quot;======&quot; ); Log.d(&quot;Scroll&quot;, &quot;dy = &quot; + dy); Log.d(&quot;Scroll&quot;, &quot;getScrollY() = &quot; + getScrollY()); Log.d(&quot;Scroll&quot;, &quot;getHeight() = &quot; + getHeight()); Log.d(&quot;Scroll&quot;, &quot;mScreenHeight() = &quot; + mScreenHeight); Log.d(&quot;Scroll&quot;, &quot;getHeight() - mScreenHeight = &quot; + (getHeight() - mScreenHeight)); Log.d(&quot;Scroll&quot;, &quot;mLastY = &quot; + mLastY); Log.d(&quot;Scroll&quot;, &quot;mStart = &quot; + mStart); if (getScrollY() &lt; 0) &#123; //最顶端，超过0时，不再下拉 //不设置这个，getScrollY一直是负数 dy = 0; &#125; if (getScrollY() &gt; getHeight() - mScreenHeight) &#123; //滑到最底端时，不再滑动 //不设置这个，getScrollY一直是大于getHeight() - mScreenHeight的数 dy = 0; &#125; scrollBy(0, (int) dy); //不断的设置Y，在滑动的时候子view就会比较顺畅 mLastY = event.getY(); break; case MotionEvent.ACTION_UP: mEnd = getScrollY(); int dScrollY = mEnd - mStart; //向上，向下滑动，超过1/3屏幕高度， //结束滑动时滚动到下个位置，没有超过时复位 if (dScrollY &gt; 0) &#123; if (dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll(0, mEnd, 0, -dScrollY, 200); &#125; else &#123; mScroller.startScroll(0, mEnd, 0, mScreenHeight - dScrollY, 200); &#125; &#125; else &#123; if (-dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll(0, mEnd, 0, -dScrollY, 200); &#125; else &#123; mScroller.startScroll(0, mEnd, 0, -(mScreenHeight + dScrollY), 200); &#125; &#125; break; &#125; // 重绘执行computeScroll() postInvalidate(); //需要返回true否则down后无法执行move和up操作 return true;&#125;/** * Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性， * 但它并不是UI，也不是滑动辅助UI运动，反而是单纯地为滑动提供计算 * 需要invalidate()之后才会调用,这个方法在onDraw()中调用 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; scrollTo(0, mScroller.getCurrY()); postInvalidate(); &#125;&#125; 事件拦截机制，涉及触摸事件MotionEvent(),onTouchEvent()，dispatchTouchEvent(),onInterceptTouchEvent(),多个View,ViewGroup之间对事件的处理 ViewGroup A,B 1234567891011121314151617@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;dispatchTouchEvent &quot;+ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;onInterceptTouchEvent &quot;+ev.getAction()); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;onTouchEvent &quot;+ev.getAction()); return super.onTouchEvent(ev);&#125; View 1234567891011@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;MyView&quot;,&quot;dispatchTouchEvent &quot;+ev.getAction()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; Log.e(&quot;MyView&quot;,&quot;onTouchEvent &quot;+ev.getAction()); return super.onTouchEvent(ev); &#125; View位置顺序是A最外层，B中间，MyView最底层。传递分发机制是A-&gt;B-&gt;MyView,处理机制时MyView-&gt;B-&gt;A 123事件传递返回值：True 拦截，不继续传递；False,不拦截，继续传递事件处理返回值：True 处理了不用传递回上级，False 给上级处理初始情况都是False]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sh 简单程序]]></title>
    <url>%2F2018%2F02%2F24%2Fsh-%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sh-demo 直接执行命令123datewho 创建变量，如果是字符串的话，有空格的一定要用双引号，否则会被解析成命令123NDK=10text=&quot;i love you&quot; 命令的执行结果作为变量的值，例如以当前时间作为文件名123text1=datetext2=$(who) 输出1234567echo $NDKecho $textecho $text1echo $text2 字符串拼接，同理：有空格需要用双引号1echo &quot;$text very much&quot; 如果需要输出$的话，需要使用转义字符1echo &quot;$&quot; 运行两种方式 1 ./bash.sh 2 sh bash.sh 如果sh command not found 或者 sh cannot open file 程序中的/r/n 换行符限制 命令退出的状态 命令执行退出的状态： 0 成功 127 没有找到命令 1 未知错误 126 命令不可执行 查看与退出状态指定： 查看上一次命令的执行状态echo $?在shell脚本中，自己指定退出的状态exit 状态码 grep命令是查找命令，例如查找test文本在test.txt中所在的行数：grep -n test test.txt 可以结合test命令，如果条件成立，test命令以状态为0退出，if条件成立。 test命令简单形式，用中括号，注意空格要加上 a -gt b 要加上空格,程序才能运行 比较大小： #!/bin/bash a=10b=5 test命令简单形式 if [ a -gt b ] then echo &quot;a greater than b&quot; else echo &quot;a smaller than b&quot; fi test数值比较： -gt 大于 -eq 等于 -le 小于 -ne 不等于 判空： #!/bin/bash str1=””if [ str1 = “” ] then echo &quot;有内容&quot;else echo &quot;没内容&quot;fi test字符串比较： str1 == str2 str1 != str2 str1 &lt; str2 -n str1 长度是否非0 -z str1 长度是否为0 检查目录是否存在： #!/bin/bash mydir=/usr/jason -d检查目录是否存在 if [ -d $mydir ] then echo &quot;$mydir exist&quot; cd $mydir ls else echo &quot;mydir not exist&quot; fi test文件比较： -d 检查是否存在，并且是一个目录 -e 检查file是否存在 -f 检查是否存在，并且是一个文件 -r 检查是否存在，并且可读，余此类推：-w、-x file1 -nt file2 file1比file2新 file1 -ot file2 file1比file2旧 case语句 基本格式是： case命令case 变量 inpattern1) 命令;;pattern2) 命令;;*) 默认命令;;esac 例子： #!/bin/bash testuser=rose case $testuser in rose) echo &quot;hi,$testuser&quot;;; ricky) echo &quot;hello, ricky&quot;;; *) echo &quot;defaults&quot;;; esac While循环 基本格式： while test command（或者[]）do 命令done 例子： #!/bin/bash a=10 while [ $a -gt 0 ] do echo &quot;num:$a&quot; 赋值不用使用$符号 a=[ a - 1 ]done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用快捷键 命令 设置等操作]]></title>
    <url>%2F2018%2F02%2F24%2FLinux-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键 Ctrl+Alt+T 打开终端 Ctrl+L 清空屏幕(功能相当于命令clear) Ctrl+U 剪切文本直到行的起始(可以用于清空行) Ctrl+K 剪切文本直到行的末尾 Ctrl+Y 粘贴最近剪切的文本 Ctrl+C 杀死当前进程(也可以用来清空当前行) Ctrl+D 退出当前Shell(功能相当于命令exit) 或者 删除当前的字符 Ctrl+A 行首 Ctrl+E 行尾 Home/End 行首/行尾 Ctrl+F 向前移动一个字符 Ctrl+B 向后移动一个字符 Ctrl+P 或 Ctrl+N 上下历史记录 上下方向键 上下历史记录 Ctrl+Shift+C 复制 Ctrl+Shift+V 粘贴 还有Tab补全,按住Ctrl键进行块选择. 鼠标中键:粘贴(在gnome-terminal中使用”菜单 键+P”也是可以粘贴的) 设置代理1.通过export http代理使用apt-get（临时有效）在使用apt-get之前，在终端中输入以下命令 12export http_proxy=&quot;&quot;export https_proxy=&quot;&quot; 2.apt.conf文件中配置http代理信息（永久有效） sudo gedit /etc/apt/apt.conf在您的apt.conf文件中加入下面这行1Acquire::http::Proxy &quot;http://proxy_addr:proxy_port&quot;; 3..bashrc文件中配置代理信息(apt-get, wget 等等)（全局有效） gedit ~/.bashrc 在.bashrc文件末尾添加如下内容1export http_proxy=&quot;http://proxy_addr:proxy_port&quot; vi操作 跳到文本的最后一行：按“G”,即“shift+g” 跳到最后一行的最后一个字符 ： 先重复1的操作即按“G”，之后按“$”键，即“shift+4”。 跳到第一行的第一个字符：先按两次“g”， 跳转到当前行的第一个字符：在当前行按“0”。 vi加密。进入vi，输入”:” + “X” 之后就提示你输入两次密码。之后:wq 保存退出。再次进入时就提示你输入密码了。如果你不想要密码了，就:X 提示你输入密码时连续按两次回车 编辑只读文件存在历史，buffer状态等，不能直接修改保存文件，解决方案1:w !sudo tee % 设置环境变量12345678910111213141516vim .bashrc echo $PATH (列出所有环境变量) echo $JAVA_HOME （列出某个环境变量值） source .bashrc (保存并且生效) NDKROOT=&apos;/home/willkernel/Downloads/android-ndk-r15c&apos;export NDKROOTexport PATH=$NDKROOT:$PATHANDROID=&apos;/home/willkernel/Downloads/android-studio/bin&apos;export ANDROIDexport PATH=$ANDROID:$PATHFFMPEG=&apos;/home/willkernel/Downloads/ffmpeg-2.6.9&apos;export FFMPEGexport PATH=$FFMPEG:$PATH 常用命令50 Most Frequently Used UNIX / Linux Commands (With Examples)50个最常用的Unix/Linux命令 其他 install lantern in Ubuntu and launch lanternsudo dpkg -i lantern *.deb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
</search>
