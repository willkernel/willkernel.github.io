<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Notes(Performance)]]></title>
    <url>%2F2018%2F03%2F08%2FAndroid-Notes-Performance%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(System Info Manager Safety)]]></title>
    <url>%2F2018%2F03%2F08%2FAndroid-Notes-System-Info-Manager-Safety-1%2F</url>
    <content type="text"><![CDATA[Android System Info android.os.Build 12345678910111213141516171819202122Build.BOARD 主板Build.BRAND 系统定制商Build.SUPPORTED_ABIS CPU指令集Build.DEVICE 设备参数Build.DISPLAY 显示屏参数Build.FINGERPRINT 唯一编号Build.SERIAL 硬件序列号Build.ID 修订版本Build.MANUFACTURER 硬件制造商Build.MODEL 版本Build.HARDWARE 硬件名Build.PRODUCT 手机产品名Build.TAGS Build 标签Build.TYPE Build 类型Build.VERSION.CODENAME 开发代号Build.VERSION.INCREMENTAL 源码控制版本号Build.VERSION.RELEASE 版本字符串Build.VERSION.SDK_INT 版本号// The following properties only make sense for internal engineering builds.Build.HOST Host值Build.USER User名Build.TIME 编译时间 SystemProperty 1234567891011121314151617String getPropertyos.version os版本os.name os名称os.arch os架构user.home Home属性user.name Name属性user.dir Dir属性user.timezone 时区path.separator 路径分隔符line.separator 行分隔符file.separator 文件分隔符java.vendor.url Java vendor url属性java.class.path Java Class属性java.class.version Java Class版本java.vendor Java vendor属性java.version Java版本java.home Java Home属性 应用 123456789101112131415String board=Build.BOARDString brand=Build.BRANDString os_version=System.getProperty(&quot;os.version&quot;)String os_name=System.getProperty(&quot;os.name&quot;)cd system/cat build.prop 查看build信息getprop ro.build.id 获取对应属性值MRA58Kcd proc/ls -al 查看文件详细信息cat cpuinfo 查看cpu信息 PackageManager(应用包信息) 123456789getPackageManager 返回PackageManager对象getApplicationInfo 返回指定包名的ApplicationInfogetApplicationIcon 返回指定包名的IcongetInstalledApplication 以ApplicationInfo形式返回安装的应用getInstalledPackages 以PackageInfo形式返回安装的应用queryIntentActivities 返回指定intent的ResolveInfo对象，Activity集合queryIntentServices 返回指定intent的ResolveInfo对象，Service集合resolveActivity 返回指定intent的ActivityresolveService 返回指定intent的Service 判断APP类型 12345 app.flags&amp;ApplicationInfo.FLAG_SYSTEM!=0为系统应用 app.flags&amp;ApplicationInfo.FLAG_SYSTEM&lt;=0则为第三方应用 特殊情况，系统应用升级后也成为第三方应用 app.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP!=0 app.flags&amp;ApplicationInfo.FLAG_EXTERNAL_STORAGE!=0为安装在SDCard应用List&lt;ApplicationInfo&gt; list=pm.getInstalledApplications(PackManager.GET_UNINSTALLED_PACKAGES/MATCH_UNINSTALLED_PACKAGES); ActivityManager(运行应用程序信息)123456789101112131415161718192021ActivityManager.MemoryInfo 全局内存使用信息availMem 系统可用内存totalMem 总内存threshold 低内存的阈值lowMemory 是否处于低内存Debug.MemoryInfo 进程下的内存信息RunningAppProcessInfoprocessName 进程名pid 进程piduid 进程uidpkgList 该进程下所有包RunningServiceInfoactiveSince 第一次激活的时间，方式foreground 服务是否在前台运行List&lt;RunningAppProcessInfo&gt; list=am.getRunningAppProcess();Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) 查看packages.xml获取系统信息1adb pull data/system/packages.xml 123codepath apk安装路径system/app 存放系统或厂商定制apkdata/app 存放第三方apk Android安全 代码混淆proguard，混淆代码，替换命名，压缩代码，优化编译后的字节码 AndroidManifest 权限声明，权限检查 1234检测操作者权限判断permission名称，如果为空，直接返回DENIED判断UID，如果为0，则为Root权限，不做权限控制；如果为system server的uid，不做权限控制；如果uid与参数中的请求uid不同，则返回DENIEDPackageManagerService.checkUidPermission()判断uid是否有相应的权限，系统级的platform.xml中进行查找 数字证书，APP签名文件 Linux内核访问权限控制，System，root用户才有权限访问系统文件 虚拟机沙箱隔离，每个APP有与之对应的UID 隐患 123代码漏洞:LaunchAnyWhere,FakeID BugRoot风险安全机制不健全 反编译工具 apktool 1234反编译 apktool.jar d test.apk生成test文件夹重新打包 apktool.jar b test.apk生成重新打包的apk，在dist文件夹中 Dex2jar,jd-gui 123dex2jar.bat classes.dex生成classes.jar文件使用jd-gui查看源码 apk加密 1234567buildTypes &#123; release&#123; minifyEnabled false //以前属性名是runProguard proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), //系统默认 &apos;proguard-rules.pro&apos; // 项目自定义 &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Activity)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[Activity，Activity调用栈 onCreate 创建基本元素 初始化资源，或在onPause中释放的资源 onPause/onStop 清除Activity资源，camera，sensor，receivers onDestory 清除线程 activity 在onSaveInstanceState()保存状态到Bundle，在onRestoreInstanceState(),onCreate()恢复状态Bundle，已经默认实项了控件的状态保存 Activity任务栈 栈底元素是整个任务栈发起者 一个任务栈Task,表示若干个Activity集合，可以来自不同的App，一个App的Activity也可以在不同的Task中 LIFO 后进先出 启动模式launchmode standard默认启动模式，每次都会创建新的实例 singleTop栈顶模式，如果栈顶是要启动的Activity，直接引用，如果不是创建新的Activity，例如qq接受多条消息，弹出的消息界面 singleTask单栈模式，要启动的Activity，如果栈中存在该Activity，将其置于栈顶，并将位于上方的Activity销毁，指同一个App中启动它的Activity，如果其他App以singleTask模式启动这个Activity，将会创建新的Activity。但是如果启动的Activity已经在一个任务栈中处于后台，那所在的任务栈会和要启动的Activity一起回到前台，当已经启动的Activity需要按返回键时，就会先返回Activity所在栈的元素应用：将主Activity设置为singleTask，然后在要退出的Activity中启动主Activity，将他之上的Activity全部销毁,重写onNewIntent(),加上finish(),将最后一个主Activity结束 singleInstanse栈中只存在该一个Activity，共享实例，不需要重新创建，类似浏览器，电话 注意：singleTop或singleInstance的Activity A通过startActivityForResult()启动另一个Activity B，直接返回Activity.RESULT_CANCELD ,只能通过Intent绑定数据 Intent Flag Intent.FLAG_ACTIVITY_NEW_TASK 启动的Activity在新的Task中，使用在Service中启动Activity，因为Service没有任务栈 Intent.FLAG_ACTIVITY_SINGLE_TOP 存在直接引用，不存在创建新的 Intent.FLAG_ACTIVITY_CLEAR_TOP 与singleTask相同，存在引用并销毁，不存在创建新的 Intent.FLAG_ACTIVITY_NO_HISTORY 以这种模式启动的Activity C会消失，A-&gt;B-&gt;C-&gt;D,当前Activity栈中为ABD 清空任务栈 clearTaskOnTouch 每次返回该Activity 清除其他Activity，初始化Task，只有一个该Activity finishOnTaskLaunch 返回该Activity时，会被finish alwaysRetainTaskState 保持当前Task状态，不接受任何清理命令]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(SurfaceView)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[SurfaceView View适用于主动刷新，SurfaceView适用于被动刷新，例如频繁刷新 View在主线程中对画面进行刷新，SurfaceView通常会在子线程进行页面刷新 View绘制时没有使用双缓冲机制，SurfaceView在底层机制中实项了双缓冲机制正弦曲线，绘画板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 private void init() &#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); setFocusable(true); setFocusableInTouchMode(true); setKeepScreenOn(true);// mSurfaceHolder.setFormat(PixelFormat.OPAQUE); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); mPath = new Path(); mDrawPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mDrawPaint.setColor(Color.RED); mDrawPaint.setStyle(Paint.Style.STROKE); mDrawPaint.setStrokeCap(Paint.Cap.ROUND); mDrawPaint.setStrokeWidth(5); mDrawPaint.setStrokeJoin(Paint.Join.ROUND); mDrawPath = new Path(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mPath.moveTo(0, getHeight() / 2); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mIsDrawing = true; Log.e(&quot;surfaceCreated&quot;, Thread.currentThread().getName()); new Thread(this).start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mIsDrawing = false; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDrawPath.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: mDrawPath.lineTo(x, y); break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; @Override public void run() &#123; while (mIsDrawing) &#123; long start = System.currentTimeMillis(); draw(); long end = System.currentTimeMillis(); //100是经验值，取值范围50-100ms if (end - start &lt; 100) &#123; try &#123; Thread.sleep(100 - (end - start)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; x += 1; y = (int) (100 * Math.sin(x * 2 * Math.PI / 180) + 100); mPath.lineTo(x, y); &#125; &#125; private void draw() &#123; try &#123; //获得canvas图像 mCanvas = mSurfaceHolder.lockCanvas(); //surfaceview 背景 mCanvas.drawColor(Color.WHITE); //绘制路径 mCanvas.drawPath(mPath, mPaint); mCanvas.drawPath(mDrawPath, mDrawPaint); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //保证每次内容的提交 if (mCanvas != null) mSurfaceHolder.unlockCanvasAndPost(mCanvas); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(Paint Shader)]]></title>
    <url>%2F2018%2F03%2F07%2FAndroid-Notes-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Paint PorterDuffXfermode 两个图层交集区域显示方式,用的最多是DST_IN,SRC_IN显示圆形图片或圆角图片 圆角矩形 123456789101112private void drawRoundRect() &#123; ImageView roundRectIv = findViewById(R.id.roundRectIv); Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); Bitmap mOut = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); PorterDuffXfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); Canvas canvas = new Canvas(mOut); canvas.drawRoundRect(0, 0, mBitmap.getWidth(), mBitmap.getHeight(), 100, 100, mPaint); mPaint.setXfermode(mXfermode); canvas.drawBitmap(mBitmap, 0, 0, mPaint); roundRectIv.setImageBitmap(mOut); &#125; 刮刮卡12345678910111213141516171819202122232425262728293031323334353637383940private void init() &#123; bgBmp = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); fgBmp = Bitmap.createBitmap(bgBmp.getWidth(), bgBmp.getHeight(), Bitmap.Config.ARGB_8888); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //画路径时走透明通道，形成刮刮卡效果 mPaint.setAlpha(0); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeJoin(Paint.Join.ROUND); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(50); mCanvas = new Canvas(fgBmp); mCanvas.drawColor(Color.GRAY); mPath = new Path(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPath.reset(); mPath.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: mPath.lineTo(x, y); break; &#125; mCanvas.drawPath(mPath, mPaint); invalidate(); return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(bgBmp, 0, 0, null); canvas.drawBitmap(fgBmp, 0, 0, null); &#125; Shader(着色器，渲染器)123CLAMP 拉伸图片最后一个像素，不断重复REPEAT 横向纵向不断重复MIRROR 横向纵向翻转重复 BitmapShader 位图shader 12345678910111213141516171819202122232425圆形图片private void init() &#123; bm = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); //图像填充功能 bitmapShader = new BitmapShader(bm, Shader.TileMode.CLAMP, Shader.TileMode.REPEAT); mPaint = new Paint(); mPaint.setShader(bitmapShader); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mLinearGradient=new LinearGradient(100,300,300,500, Color.RED,Color.YELLOW, Shader.TileMode.CLAMP); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200, 200, 100, mPaint); mPaint.setShader(mLinearGradient); canvas.drawRect(100,300,300,500,mPaint); &#125; LinearGradient 线性shader RadialGradient 光束shader SweepGradient 梯度shader ComposeShader 混合shader 图像倒影 1234567891011121314151617181920212223242526private void init() &#123; mSrcBitmap= BitmapFactory.decodeResource(getResources(), R.mipmap.car3); Matrix matrix=new Matrix(); //实项垂直翻转，(-1,1)实项水平翻转 matrix.setScale(1,-1); mRefBitmap=Bitmap.createBitmap(mSrcBitmap,0,0, mSrcBitmap.getWidth(),mSrcBitmap.getHeight(),matrix,true); mPaint=new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setShader(new LinearGradient(0,mSrcBitmap.getHeight(), 0,mSrcBitmap.getHeight()+mSrcBitmap.getHeight()/4, 0xdd000000,0x33000000, Shader.TileMode.CLAMP)); mXferMode=new PorterDuffXfermode(PorterDuff.Mode.DST_IN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.BLACK); canvas.drawBitmap(mSrcBitmap,0,0,null); canvas.drawBitmap(mRefBitmap,0,mSrcBitmap.getHeight(),null); mPaint.setXfermode(mXferMode); canvas.drawRect(0,mSrcBitmap.getHeight(),mRefBitmap.getWidth(), mSrcBitmap.getHeight()*2,mPaint); mPaint.setXfermode(null); &#125; PathEffect ComposePathEffect 先应用一种路径效果，再这个基础上混合另外一种效果 CornerPathEffect 圆角路径 DashPathEffect 虚线路径 DiscretePathEffect 杂点路径 PathDashPathEffect 设置点的图形路径效果 SumPathEffect 组合两种路径后再应用到图形上 12345678910111213141516171819202122232425262728293031private void init() &#123; mEffects=new PathEffect[7]; mPaint=new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(4); mPath=new Path(); mPath.moveTo(0,0); for (int i = 0; i &lt;=30; i++) &#123; mPath.lineTo(i*35, (float) (Math.random()*100)); &#125; mEffects[0]=null; mEffects[1]=new CornerPathEffect(30); mEffects[2]=new DiscretePathEffect(5,3); mEffects[3]=new DashPathEffect(new float[]&#123;10,20,30,50&#125;,0); Path path=new Path(); path.addRect(0,0,10,10, Path.Direction.CCW); mEffects[4]=new PathDashPathEffect(path,12,0, PathDashPathEffect.Style.ROTATE); mEffects[5]=new ComposePathEffect(mEffects[3],mEffects[1]); mEffects[6]=new SumPathEffect(mEffects[3],mEffects[1]); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); for (PathEffect mEffect : mEffects) &#123; mPaint.setPathEffect(mEffect); canvas.drawPath(mPath,mPaint); canvas.translate(0,200); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes(View)]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid-Notes-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Android 绘图机制处理 系统屏幕密度，密度值，分辨率对应关系 1ldpi=120(240*320),mdpi=160(320*480)，hdpi=240(480*800),xhdpi=320(720*1280),xxhdpi=480(1080*1980) 独立像素密度(密度无关像素 (dp)在定义 UI 布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度 或位置) 1ldpi:mdpi:hdpi:xhdpi:xxhdpi=120:160:240:320:480=0.75px:1px:1.5px:2px:3px=3:4:6:8:12 单位转换 12345678910scale=getResources().getDisplayMetrics().density;px2dp: pxValue/scale+0.5f;dp2px: dpValue*scale+0.5f;fontScale=getResources().getDisplayMetrics().scaledDensity;px2sp: pxValue/fontScale+0.5f;sp2px: pxValue*fontScale+0.5f;TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,dp,getResource().getDisplayMetrics()); 2D绘图 setAntiAlias()//画笔锯齿 setColor()//画笔颜色 setARGB() setAlpha() setTextSize() setStyle()//空心，实心 setStrokerWidth()//边框宽度1234567891011drawPointdrawLinedrawLinesdrawRectdrawRoundRectdrawCircledrawArc 绘制弧形，使用中心或实心，空心drawOval 绘制椭圆drawText 绘制文本drawPosText 指定位置绘制文本drawPath 绘制路径 XML Bitmap 12&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@mipmap/car1&quot; /&gt; Shape 123456789101112131415&lt;shape android:shape=&quot;rectangle|oval|line|ring&quot;&gt;&lt;!--配合ImageView scaleType--&gt;&lt;size android:width=&quot;12dp&quot; android:height=&quot;12dp&quot; /&gt;&lt;!--虚线宽度，间隔--&gt;&lt;stroke android:width=&quot;20dp&quot; android:color=&quot;@color/colorAccent&quot; android:dashGap=&quot;2dp&quot; android:dashWidth=&quot;6dp&quot; /&gt;&lt;/shape&gt; Layer 1234&lt;layer-list&lt;item android:drawable=&quot;@mipmap/car1&quot;/&gt;&lt;item android:drawable=&quot;@mipmap/car2&quot;/&gt;&lt;/layer-list&gt; Selector 1234567891011&lt;item android:drawable=&quot;@android:drawable/btn_default&quot; /&gt; &lt;!--没有焦点时--&gt; &lt;item android:state_window_focused=&quot;false&quot; /&gt; &lt;!--非触摸单击时--&gt; &lt;item android:state_focused=&quot;true&quot; android:state_pressed=&quot;true&quot; /&gt; &lt;!--触摸模式下单击时--&gt; &lt;item android:state_focused=&quot;false&quot; android:state_pressed=&quot;true&quot; /&gt; &lt;!--选中时--&gt; &lt;item android:state_selected=&quot;true&quot; /&gt; &lt;!--获得焦点时--&gt; &lt;item android:state_focused=&quot;true&quot; /&gt; 绘图技巧 Canvas 123456789//保存之前绘制图像，后续绘制在新的图层canvas.save()//save之前的图像和之后的图像合并canvas.restore() //坐标系平移，原点(0,0)移动到(x,y)canvas.translate()//坐标系旋转canvas.rotate() Board 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.RED); mPaint.setStrokeWidth(2);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); mHeight = getHeight();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mWidth / 2, mHeight / 2, mWidth / 2, mPaint); for (int i = 0; i &lt; 24; i++) &#123; if (i == 0 || i == 6 || i == 12 | i == 18) &#123; mPaint.setStrokeWidth(5); mPaint.setTextSize(30); canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2, mWidth / 2, mHeight / 2 - mWidth / 2 + 60, mPaint); canvas.drawText(String.valueOf(i), mWidth / 2, mHeight / 2 - mWidth / 2 + 90, mPaint); &#125; else &#123; mPaint.setStrokeWidth(3); mPaint.setTextSize(16); canvas.drawLine(mWidth / 2, mHeight / 2 - mWidth / 2, mWidth / 2, mHeight / 2 - mWidth / 2 + 30, mPaint); canvas.drawText(String.valueOf(i), mWidth / 2, mHeight / 2 - mWidth / 2 + 60, mPaint); &#125; //旋转画布简化角度,坐标运算 canvas.rotate(15, mWidth / 2, mHeight / 2); &#125; canvas.save(); mPaint.setColor(Color.CYAN); mPaint.setStrokeWidth(10); canvas.translate(mWidth / 2, mHeight / 2); canvas.drawLine(0, 0, 100, 100, mPaint); canvas.drawLine(0, 0, 100, 200, mPaint); canvas.restore();&#125; layer图层 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.BLUE); canvas.drawCircle(mWidth / 2, mHeight / 2, 50, mPaint); canvas.saveLayerAlpha(0, 0, mWidth, mHeight, 127, ALL_SAVE_FLAG); mPaint.setColor(Color.RED); canvas.drawCircle(mWidth / 2 + 50, mHeight / 2 + 50, 50, mPaint); canvas.restore();&#125; 色彩特效 图片的数据结构常使用位图Bitmap,由点阵(像素点矩阵)和颜色值(ARGB)组成 色彩处理中包含色调，饱和度，亮度，使用ColorMatrix(4*5颜色矩阵) 1234567891011121314151617181920212223242526272829303132333435[a, b, c, d, e,f, g, h, i, j,k, l, m, n, o,p, q, r, s, t ]在Android中以一维数组存储 float[] mArray = new float[20]R = a*R + b*G + c*B + d*A + e;G = f*R + g*G + h*B + i*A + j;B = k*R + l*G + m*B + n*A + o;A = p*R + q*G + r*B + s*A + t;初始矩阵不会对颜色改变A=[1,0,0,0,00,1,0,0,00,0,1,0,00,0,0,1,0]色调setRotate(int axis,floate degrees)axis=0 the RED coloraxis=1 the GREEN coloraxis=2 the BLUE color饱和度，为0时是灰度图像setSaturation(float sat)亮度setScale(float rScale, float gScale, float bScale,float aScale)矩阵乘法运算postConcat(ColorMatrix postmatrix)setConcat(postmatrix, this)imageMatrix.postContact(hueMatrix)imageMatrix.postContact(saturationMatrix)imageMatrix.postContact(lumMatrix) 滑动seekbar，改变颜色混合效果 123456789101112131415161718192021222324252627282930313233343536373839404142public static Bitmap handleImageEffect(Bitmap bm, float hue, float saturation, float lum) &#123; Bitmap bmp = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(); ColorMatrix hueMatrix = new ColorMatrix(); hueMatrix.setRotate(0, hue); hueMatrix.setRotate(1, hue); hueMatrix.setRotate(2, hue); ColorMatrix saturationMatrix = new ColorMatrix(); saturationMatrix.setSaturation(saturation); ColorMatrix lumMatrix = new ColorMatrix(); lumMatrix.setScale(lum, lum, lum, 1); ColorMatrix imageMatrix = new ColorMatrix(); imageMatrix.postConcat(hueMatrix); imageMatrix.postConcat(saturationMatrix); imageMatrix.postConcat(lumMatrix); paint.setColorFilter(new ColorMatrixColorFilter(imageMatrix)); canvas.drawBitmap(bm, 0, 0, paint); return bmp; &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; switch (seekBar.getId()) &#123; case R.id.hueSeekBar: mHue = (progress - 50) * 1.0f / 50 * 180; break; case R.id.saturationSeekBar: mSaturation = progress * 1.0f / 50; break; case R.id.lumSeekBar: mLum = progress * 1.0f / 50; break; &#125; filterImage.setImageBitmap(ColorMatrixUtil.handleImageEffect(bm, mHue, mSaturation, mLum)); &#125; Android不允许直接修改原图，创建同大小的位图，并将原图绘制到该Bitmap 1234Bitmap bmp=Bitmap.createBitmap(bm.getWidth(),bm.getHeight(),Bitmap.Config.ARGB_8888);Canvas canvas=new Canvas(bmp);paint.setColorFilter(new ColorMatrixColorFilter(matrix));canvas.drawBitmap(bm,0,0,paint); ColorMatrix 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void addEts() &#123; gridLayout.post(new Runnable() &#123; int mEtHeight; int mEtWidth; @Override public void run() &#123; mEtHeight = gridLayout.getWidth() / 4; mEtWidth = gridLayout.getWidth() / 5; for (int i = 0; i &lt; 20; i++) &#123; EditText editText = new EditText(getBaseContext()); gridLayout.addView(editText, mEtWidth, mEtHeight); mEts[i] = editText; &#125; initMatrix(); &#125; &#125;); &#125; private void initMatrix() &#123; for (int i = 0; i &lt; mEts.length; i++) &#123; if (i % 6 == 0) &#123; mEts[i].setText(&quot;1&quot;); &#125; else &#123; mEts[i].setText(&quot;0&quot;); &#125; &#125; &#125; private void getMatrix() &#123; for (int i = 0; i &lt; mEts.length; i++) &#123; mColorMatrix[i] = Float.valueOf(mEts[i].getText().toString()); &#125; &#125; private void setImageMatrix() &#123; Bitmap bmp = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint paint = new Paint(); ColorMatrix colorMatrix = new ColorMatrix(mColorMatrix); paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bm, 0, 0, paint); filterImage.setImageBitmap(bmp); &#125; 图像反转 获取图像像素值,三种像素点处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void getPixels() &#123; ImageView pixelImage1 = findViewById(R.id.pixelImage1); ImageView pixelImage2 = findViewById(R.id.pixelImage2); ImageView pixelImage3 = findViewById(R.id.pixelImage3); bm = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); int[] pixels = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels1 = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels2 = new int[bm.getWidth() * bm.getHeight()]; int[] newPixels3 = new int[bm.getWidth() * bm.getHeight()]; bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); Bitmap bmp1 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Bitmap bmp2 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); Bitmap bmp3 = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), Bitmap.Config.ARGB_8888); for (int i = 0; i &lt; pixels.length; i++) &#123; int color = pixels[i]; int r = Color.red(color); int g = Color.green(color); int b = Color.blue(color); int a = Color.alpha(color); //老照片 int r1 = (int) (0.393 * r + 0.769 * g + 0.189 * b); int g1 = (int) (0.349 * r + 0.686 * g + 0.168 * b); int b1 = (int) (0.272 * r + 0.534 * g + 0.131 * b); newPixels1[i] = Color.rgb(r1, g1, b1); //底片处理 int r2 = 255 - r; int g2 = 255 - g; int b2 = 255 - b; if (r &gt; 255) &#123; r = 255; &#125; else if (r &lt; 0) &#123; r = 0; &#125; if (g &gt; 255) &#123; g = 255; &#125; else if (g &lt; 0) &#123; g = 0; &#125; if (b &gt; 255) &#123; b = 255; &#125; else if (b &lt; 0) &#123; b = 0; &#125; newPixels2[i] = Color.argb(a, r2, g2, b2); //浮雕 int rB = 0; int gB = 0; int bB = 0; if (i + 1 &lt; pixels.length) &#123; int colorB = pixels[i + 1]; rB = Color.red(colorB); gB = Color.green(colorB); bB = Color.blue(colorB); rB = r - rB + 127; gB = g - gB + 127; bB = b - bB + 127; if (rB &gt; 255) &#123; rB = 255; &#125; if (gB &gt; 255) &#123; gB = 255; &#125; if (bB &gt; 255) &#123; bB = 255; &#125; &#125; newPixels3[i] = Color.rgb(rB, gB, bB); &#125; bmp1.setPixels(newPixels1, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); bmp2.setPixels(newPixels2, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); bmp3.setPixels(newPixels3, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); pixelImage1.setImageBitmap(bmp1); pixelImage2.setImageBitmap(bmp2); pixelImage3.setImageBitmap(bmp3); &#125; 图像变换矩阵初始矩阵 123[1 0 0 0 1 0 0 0 1] 图像处理基本变换 Translate 1234567p(x0,y0)-&gt;p(x,y)x=Δx+x0y=Δy+y0变换矩阵[1 0 Δx 0 1 Δy 0 0 1 ] Rotate 以坐标原点为中心旋转 Scale 每个点的坐标等比例缩放 Skew 保持所有点的x或y轴坐标不变，对应的y或x坐标等比例平移，有水平错切和垂直错切 123456matrix.setRotate()matrix.setTranslate()matrix.setScale()matrix.setSkew()set()会重置pre().post()前乘后乘对矩阵混合使用 drawBitmapMesh()像素块 12改变图像坐标值重新定位每一个图像块drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight,@NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset,@Nullable Paint paint) 旗帜FlagView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public class FlagView extends View &#123; private float[] orig, verts; int HEIGHT = 100, WIDTH = 100; //振幅 private float A = 20; private Bitmap bitmap; private float k; public FlagView(Context context) &#123; this(context, null); &#125; public FlagView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public FlagView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.car3); int bitmapWidth = bitmap.getWidth(); int bitmapHeight = bitmap.getHeight(); int index = 0; orig = new float[bitmapHeight * bitmapWidth]; verts = new float[bitmapHeight * bitmapWidth]; for (int y = 0; y &lt;= HEIGHT; y++) &#123; float fy = bitmapHeight * y / HEIGHT; for (int x = 0; x &lt;= WIDTH; x++) &#123; float fx = bitmapWidth * x / WIDTH; orig[index * 2 + 0] = verts[index * 2 + 0] = fx; //+100 避免被遮挡 orig[index * 2 + 1] = verts[index * 2 + 1] = fy + 100; index += 1; &#125; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); flagWave(); k += 0.1f; canvas.drawBitmapMesh(bitmap, WIDTH, HEIGHT, verts, 0, null, 0, null); invalidate(); &#125; private void flagWave() &#123; for (int j = 0; j &lt;= HEIGHT; j++) &#123; for (int i = 0; i &lt;= WIDTH; i++) &#123; verts[(j * (WIDTH + 1) + i) * 2 + 0] += 0; //图像动起来，纵坐标周期性变化 float offsetY = (float) Math.sin((float) i / WIDTH * 2 * Math.PI + Math.PI * k); verts[(j * (WIDTH + 1) + i) * 2 + 1] = orig[(j * WIDTH + i) * 2 + 1] + offsetY * A; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes (ListView Scroller)]]></title>
    <url>%2F2018%2F03%2F02%2FAndroid-Notes-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[ListView使用技巧 优化技巧 ViewHolder-ListView 视图缓存机制 设置分割线divider=”@null”透明 取消点击效果，listSelector smoothScrollBy/ToPosition() 处理空ListView,listView.setEmptyView(ImageView) 滑动监听，onTouchListener,onScrollListener,GestureDetector手势识别,VelocityTracker滑动速度检测 拓展 滚动到顶部，底部时有个弹性距离可以继续滑动，松开后回弹 123456789private void init()&#123; mMaxOverDistance= (int) (getResources().getDisplayMetrics().density*mMaxOverDistance);&#125;@Overrideprotected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) &#123; Log.e(&quot;overscroll&quot;,&quot;by &quot;+mMaxOverDistance); return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxOverDistance, isTouchEvent);&#125; 聊天ListView getItemViewType(position)-&gt; mData.get(position).getType() getViewTypeCount()-&gt;2 getView()区分type，实例化不同布局添加内容 listview选中未选中状态: 在getView()中判断，点击选中的item的position和当前position是否相同，添加不同的布局 Android Scroll滑动效果是触摸事件不断改变View的坐标，移动位置，来达到滑动效果 触摸事件类型 12345678910111213141516171819202122232425 //单点触摸按下 public static final int ACTION_DOWN= 0; //单点触摸离开 public static final int ACTION_UP= 1; //触摸点移动 public static final int ACTION_MOVE= 2; //触摸动作取消 public static final int ACTION_CANCEL= 3; //触摸动作超出边界 public static final int ACTION_OUTSIDE= 4; //多点触摸按下 public static final int ACTION_POINTER_DOWN= 5; //多点触摸离开 public static final int ACTION_POINTER_UP= 6; int x = (int) event.getX();int y = (int) event.getY();switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_UP: break; case MotionEvent.ACTION_MOVE: break;&#125; 实项滑动的七种方法 layout() 123456789101112131415161718192021222324252627282930313233343536相对于视图坐标系的获取坐标getX,getY,而lastX,lastY不需要重新设置坐标,因为相对于视图坐标，点击屏幕获取到的坐标会重新设置对于Android屏幕坐标系，getRawX,getRawY,lastRawX,lastRawY需要重新设置，获取准确的偏移量，第一次坐标位置getRawX,getRawY在(10,10),在移动到(20,20)，偏移量为10，此时不重新设置，下个点是(50,50),偏移量是50-10=40,而实际正确的偏移量为50-20=30@Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int rx = (int) event.getRawX(); int ry = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; lastrX = rx; lastrY = ry; break; case MotionEvent.ACTION_MOVE: int dx = x - lastX; int dy = y - lastY; int rdx = rx - lastrX; int rdy = ry - lastrY; Log.e(&quot;drag&quot;, &quot;x=&quot; + x + &quot; y=&quot; + y + &quot; lastX=&quot; + lastX + &quot; lastY=&quot; + lastY); Log.e(&quot;drag&quot;, &quot;rx=&quot; + rx + &quot; ry=&quot; + ry + &quot; lastrX=&quot; + lastrX + &quot; lastrY=&quot; + lastrY); Log.e(&quot;drag&quot;, &quot;dx=&quot; + dx + &quot; dy=&quot; + dy + &quot; rdx=&quot; + rdx + &quot; rdy=&quot; + rdy); layout(getLeft() + dx, getTop() + dy, getRight() + dx, getBottom() + dy);// lastrX = x;// lastrY = y; break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; offsetLeftAndrRight(),offsetTopAndBottom() 12offsetLeftAndRight(dx);offsetTopAndBottom(dy); LayoutParams(),ViewGroup.MarginLayoutParams 123456789FrameLayout.LayoutParams layoutParams= (FrameLayout.LayoutParams) getLayoutParams();layoutParams.leftMargin=getLeft()+dx;layoutParams.topMargin=getTop()+dy;setLayoutParams(layoutParams);ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();layoutParams.leftMargin = getLeft() + dx;layoutParams.topMargin = getTop() + dy;setLayoutParams(layoutParams); ScrollTo(x,y)/ScrollBy(dx,dy) 1234567891011121314151617181920212223 ViewGroup 移动的是子View View移动的是内容 //移动的是屏幕下方画布，会造成内容向相反方向移动 //scrollBy(dx,dy); //所以移动父视图，并且值为负，相反方向scrollby才有正确的效果case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; if (!isScroll) &#123; lastrX = rx; lastrY = ry; &#125; break;case MotionEvent.ACTION_MOVE: int dx = x - lastX; int dy = y - lastY; //移动的是屏幕下方画布，会造成内容向相反方向移动 // scrollBy(dx,dy); //((View) getParent()).scrollBy(-dx, -dy); ((View) getParent()).scrollTo(-(int) event.getRawX() + lastrX, -(int) event.getRawY() + lastrY); isScroll = true; break; Scroller 实现平移滑动 初始化Scroller 1mScroller=new Scroller(context); 重写computeScroll()模拟滑动 1234567891011 @Override public void computeScroll() &#123; super.computeScroll(); //判断Scroll是否执行完毕，true 没有执行完 if(mScroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); //只能通过invalidate()—&gt;draw()-&gt;computeScroll()间接调用computeScroll()， //结束后computeScrollOffset()返回false，中断循环 postInvalidate(); &#125;&#125; startScroll 开始模拟滑动 123456789101112131415161718192021222324252627@Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); int rx = (int) event.getRawX(); int ry = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; lastRx = rx; lastRy = ry; break; case MotionEvent.ACTION_MOVE: ((View) getParent()).scrollTo(-rx + lastRx, -ry + lastRy); break; case MotionEvent.ACTION_UP: View parent = (View) getParent(); //模拟滑动，起始坐标和偏移量，滑动偏移为滑动距离的负数，相反方向滑动 mScroller.startScroll(parent.getScrollX(), parent.getScrollY(), -parent.getScrollX(), -parent.getScrollY()); //通知重绘 invalidate(); break; &#125; return true; &#125; ViewDragHelper实项Drawlayout菜单侧滑 youtubelayout 回调 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; /**重写tryCaptureView,何时开始检测触摸事件， * 当前触摸的是MainView时开始检测*/ @Override public boolean tryCaptureView(View child, int pointerId) &#123; return mMainView == child; &#125; /**水平垂直方向上的滑动,默认返回0，不滑动*/ @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123;// return super.clampViewPositionHorizontal(child, left, dx); return left; &#125; @Override public int clampViewPositionVertical(View child, int top, int dy) &#123;// return super.clampViewPositionVertical(child, top, dy); return top; &#125; /**拖动结束后调用，自动滑动打开或关闭菜单*/ @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); if (mMainView.getTop() &gt; mHeight / 2) &#123; mViewDragHelper.smoothSlideViewTo(mMainView, 0, (int) (mHeight * 1.2f)); &#125; else &#123; if (mMainView.getLeft() &lt; mWidth / 2) &#123; //关闭菜单 mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0); &#125; else &#123; mViewDragHelper.smoothSlideViewTo(mMainView, (int) (mWidth * 1.2f), 0); &#125; &#125; ViewCompat.postInvalidateOnAnimation(ViewDragHelperView.this); &#125; /**更改scale进行缩放*/ @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); &#125; /**状态改变*/ @Override public void onViewDragStateChanged(int state) &#123; super.onViewDragStateChanged(state); &#125; /**触摸后回调*/ @Override public void onViewCaptured(View capturedChild, int activePointerId) &#123; super.onViewCaptured(capturedChild, activePointerId); &#125; &#125;; 获取宽度 123456@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = mMenuView.getMeasuredWidth(); mHeight = mMenuView.getMeasuredHeight(); &#125; 获取MenuView,MainView 123456@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mMenuView = getChildAt(0); mMainView = getChildAt(1);&#125; 触摸事件拦截，并传递给VieDragHelper 12345678910111213141516/** * 触摸事件传递给ViewDragHelper,必须写 */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mViewDragHelper.processTouchEvent(event); return true;&#125;/** * 重写事件拦截方法，把事件传递给ViewDragHelper */@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125; 重写computeScroll() 12345678910/** * 平滑移动 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mViewDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker 编译Android源码]]></title>
    <url>%2F2018%2F02%2F26%2FDocker-%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Windows 安装Docker Cannot install packages inside docker Ubuntu image 1234567891011It is because there is no package cache in the image, you need to run:apt-get -qq updatebefore installing packages, and if your command is in a Dockerfile, you&apos;ll then need:apt-get -qq -y install curlAlways combine RUN apt-get update with apt-get install in the same RUN statement, for exampleRUN apt-get update &amp;&amp; apt-get install -y package-bar 参考使用Docker编译Android系统源码 Ubuntu14.10 编译 Android5.0 源码 更换系统镜像源 apt-get install wget wget 网址而要让档案自动储存到指令的目录下，则需要借用-P这个参数，可以使用以下的指令 wget -P 目录 网址举例来说，如果你要放到/root底下，你可以打下列的指令：wget -P /root 网址 安装配置openjdk-7-jreubuntu 16 无法安装jdk7解决办法 12345678910111213sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update sudo apt-get install openjdk-7-jdkvim/gedit ~/.bashrcexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/bin/tools.jar:$JRE_HOME/binexport ANDROID_JAVA_HOME=$JAVA_HOMEexport USE_CCACHE=1source ~/.bashrc 安装其他工具 12345678910111213141516dpkg --print-architecture # 若支持，输出 amd64dpkg --print-foreign-architectures # 若支持，输出 i386//手动开启支持dpkg --add-architecture i386apt-get updatesudo apt-get install gcc-multilib g++-multilib build-essentialsudo apt-get install git-core gnupg bison flex gperf pngcrush bc zip curl lzopsudo apt-get install schedtool libxml2 libxml2-utils xsltproc squashfs-toolssudo apt-get install libesd0-dev libsdl1.2-dev libwxgtk2.8-dev libswitch-perlsudo apt-get install libssl1.0.0 libssl-dev lib32readline-gplv2-dev libncurses5-devcd /AOSPexport USE_CCACHE=1export CCACHE_DIR=/&lt;path_of_your_choice&gt;/.ccacheprebuilts/misc/linux-x86/ccache/ccache -M 50G windows 上创建/androidsource git clone https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git输入命令，切换到manifest目录 cd manifest Git tag 列出android各个分支版本下载android-android-5.1.1_r9git checkout android-5.1.1_r9 运行 python download-src.py 1234567891011121314151617181920212223242526272829import xml.dom.minidom import os from subprocess import call #downloaded source path rootdir = &quot;E:/androidsource&quot; #git program path git = &quot;D:/Git/bin/git.exe&quot;dom = xml.dom.minidom.parse(&quot;E:/androidsource/manifest/default.xml&quot;) root = dom.documentElementprefix = git + &quot; clone https://aosp.tuna.tsinghua.edu.cn/&quot; suffix = &quot;.git&quot; if not os.path.exists(rootdir): os.mkdir(rootdir) for node in root.getElementsByTagName(&quot;project&quot;): os.chdir(rootdir) d = node.getAttribute(&quot;path&quot;) last = d.rfind(&quot;/&quot;) if last != -1: d = rootdir + &quot;/&quot; + d[:last] if not os.path.exists(d): os.makedirs(d) os.chdir(d) cmd = prefix + node.getAttribute(&quot;name&quot;) + suffix call(cmd) 出现 curl: (22) The requested URL returned error: 404 Not Found Server does not provide clone.bundle; ignoring. 怎么办？无视即可 下载repo 123456789101112131415161718192021mkdir ~/binPATH=~/bin:$PATHcurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo(或者下面的地址)curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repochmod a+x reporepo的运行过程中会尝试访问官方的git源更新自己，如果想可以使用[tuna的镜像](https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/)源进行更新，可以将如下内容复制到你的~/.bashrc里export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;并重启终端模拟器cd /AOSP初始化同步reporepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-5.1.1_r9repo sync -f -j4AOSP 未下完成是不显示文件，.repo是隐藏文件夹，ctrl+h显示有问题时删除缓存文件rm -rf * -R 设置repo环境变量 123vim ~/.bashrcexport PATH=~/bin:$PATHsource ~/.bashrc Ubuntu 下载源码 start a shell session in a running container 12345docker exec -it 98e0b4f60ec3 bash$ sudo docker attach 665b4a1e17b6 #by ID or$ sudo docker attach loving_heisenberg #by Name$ root@665b4a1e17b6:/# Windows mount shared folder to Ubuntu 12345678910111213141516171819202122In Window Host:-1. Create a folder &quot;aosp&quot; -- Window2. Right Click on &quot;nandan&quot; -- Properties -- sharing -- Advance Sharing3. Check option &quot;share this folder&quot; - permission -remove Group or Username &quot;Everyone&quot;.4. Add User - select your user account from List5. Check Full Control,Read,Change6. Applu- Ok - Exit7. open cmd - ipconfig - copy ipv4 for Wireless lan Adapter incase if you are using WIFI----------------In Ubuntu VM :-1. Open terminal.. 2. become root $sudo su-3. apt-cache search cifs4. if cifs utils not present then install $ sudo apt-get install cifs-utils5. df -h6. $sudo mkdir /media/test7. $sudo mount.cifs-o username= window_username //window_ip_address/window_share_folder_name /media/test复制win共享文件夹到Ubuntucp -r aosp(win shared folder) AOSP Android系统源代码的下载与编译 初始化源码所需环境变量和参数 1source build/envsetup.sh lunch 命令选择编译目标 make -j16 (nproc 查看cpus)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 c++]]></title>
    <url>%2F2018%2F02%2F26%2F%E7%AE%97%E6%B3%95-c%2F</url>
    <content type="text"><![CDATA[排序算法]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Notes (System ADB UI)]]></title>
    <url>%2F2018%2F02%2F25%2FAndroid-Notes%2F</url>
    <content type="text"><![CDATA[Android系统架构 Android系统分四层：Linux内核层，库和运行时，Framework层和应用层。 Linux包括硬件驱动，进程管理，安全系统 Dalvik虚拟机，运行时编译；ART虚拟机安装时编译 Framework ActivityManager BackupManager Bluetooth ContentProviders LocationManger Map libraries MediaPlayer NotificationManager PackageManager ResourceManager SearchManager SharedPreference TelephoneManager WidgetProvider WindowManager ViewSystem XMPPService 标准库 Apache HTTP OpenGL ES Open SSL SQLite Webkit ICU Android NDK/SDK APP(解压后包含内容中有) AndroidManifeset Dalvik Classes Resource bundle NDK APP中包含JNI lib App组件 Activity BroardCastReceiver ContentProvider Service Context Application Context(应用启动时创建，整个生命周期) Activity Context Service Context Android 源代码目录与系统目录 Android源代码目录 Makefile (自动化编译，定制规则) bionic (bionic C库) bootable (启动引导相关代码) build (系统编译规则等基础开发包配置) cts (Google兼容性测试标准) dalvik (dalvik虚拟机) development (应用程序开发) external (开源模块) frameworks (框架) hardware (硬件适配层HAL代码) out (编译完成后代码输出目录) packages (应用程序包) prebuilt (x86 arm 架构下预编译资源) sdk system (底层文件系统库，应用及组件) vendor (厂商定制代码) Android 系统目录 (ADB ls命令查看系统目录) /system/app/ 系统app /system/bin/ Linux自带组件 /system/build.prop/ 系统属性信息 /system/fonts/ 字体 /system/framework/ 核心文件，框架层 /system/lib/ .so文件 /system/media/ 音频，闹钟，短信，来电等铃声 /system/usr/ 用户配置文件，键盘布局，共享，时区文件 /data/app/ 安装或升级的app /data/data/ App数据文件，数据库等信息 /data/system/ 系统信息 /data/misc/ WIFI，蓝牙，签名，VPN等信息 Android 开发工具 SDK镜像地址 android-studio Genymotion 安装arm架构Genymotion-ARM-Translation Android Debug ADB Command (SDK platform-tools) adb shell ls|grep “data” / cd data android list target 显示系统Android平台 id:1 or android-19 adb install -r a.apk 重新安装保留数据，安装位置/data/local/tmp/a.apk adb push a.apk /system/app 文件写入存储系统，有权限时可以安装系统应用 adb push /system/temp/ c:\Desktop 从手机获取文件 adb shell -&gt; logcat|grep “abc” 查看log adb remount(重新挂载系统分区，使系统分区重新可写) -&gt; adb shell -&gt; cd system/app -&gt; rm a.apk adb shell df 查看系统盘符 adb shell pm list packages -f 输出所有安装应用 adb shell input keyevent 3 模拟按键输入 keycode adb shell input touchscreen swipe 18 655 18 500 模拟滑动输入 adb shell dumpsys activity activities|grep “tencent” 列出activity 运行状态，过滤”tencent” pm list packages -f 列出所有package adb shell am start -n com.qiyi.video/org.qiyi.android.video.MainActivity 启动一个Activity adb shell screenrecord /sdcard/a.mp4 录制屏幕 adb reboot 重启 adb 命令来源 /frameworks/base/cmds/ /system/core/toolbox/ Android 自定义控件 控件架构 ContentView id为content的FrameLayout, onCreate()方法中调用setContentView()后ActivityManagerService会回调onResume()，此时系统才会把DecorView添加到PhoneWindow中，显示并完成绘制 View的测量 onMeasure() MeasureSpec 32位int值，高2位为测量的模式，低30位为测量的大小 EXACTLY 精确值模式，具体数值 AT_MOST 最大值模式，尺寸不超过父控件允许的最大尺寸 UNSPECIFIED 不指定，自定义view时使用,如果View要支持wrap_content,重写onMeasure()指定wrap_content时的大小 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 123456789101112131415161718/** * 宽高值自定义，在wrap_content时如果没有指定大小就会默认填充整个父布局 */private int measureWidth(int measureSpec)&#123; int result=0; int specMode=MeasureSpec.getMoode(measureSpec); int specSize=MeasureSpec.getSize(measureSpec); if(specMode=MeasureSpec.EXACTLY)&#123; result=specSize; &#125;else&#123; result=200; if(specMode=MeasureSpec.AT_MOST)&#123; result=Math.min(result,specSize) &#125; &#125; return result;&#125; View的绘制 重写onDraw(Canvas canvas) Canvas 画板1234567canvas.drawBitmap(bitmap1,0,0,null);canvas.drawBitmap(bitmap2,0,0,null);装载画布Canvas mCanvas=new Canvas(bitmap2);mCanvas.drawXXX刷新view的时候，bitmap2发生改变，没有把图形直接绘制在canvas,而是通过改变bitmap2绘制复杂图形，绘制多个拆分的小图形单元 ViewGroup的测量在wrap_content时遍历子View的大小，决定自己的大小，其他模式下通过具体的指定值设置大小。遍历子View，调用子View的Measure方法获得每一个子View 的测量结果，然后遍历子View进行布局Layout,重写onLayout()控制子View显示位置的逻辑，如果支持wrap_content需要重写onMeasure() ViewGroup的绘制 绘制背景颜色以及遍历子View的绘制 自定义View比较重要的回调方法 onFinishInflate() onSizeChanged() onMeasure() onLayout() onDraw() onTouchEvent() 对原生控件扩展 改变绘制顺序，需要改变画布位置状态时，先保存状态，等改变后，再恢复 12345....canvas.save();canvas.translate(10,0);super.onDraw(canvas);canvas.restore(); LinearGradient,Matrix实项文字闪动效果，onSizeChanged()中初始化，根据宽度设置LinearGradient渐变渲染器 1234567891011121314151617181920212223242526protected void onSizeChanged(int w,int h,int oldw,int oldh)&#123; super.onSizeChanged(w,h,oldw,oldh); if(mViewWidth==0)&#123; mViewWidth=getMeasureWidth(); if(mViewWidth&gt;0)&#123; //获取Paint,设置LinearGradient mPaint=getPaint(); mLinearGradient=new LinearGradient(0,0,mViewWidth,0,new int[] &#123;Color.BLUE,Color.RED&#125;,null,Shader.TitleMode.CLAMP); //设置着色器 mPaint.setShader(mLinearGradient) //平移变换矩阵 mGradientMatrix=new Matrix(); &#125; &#125; &#125;public void onDraw(Canvas canvas)&#123; if(mGradientMatrix!=null)&#123; mTranslate+=mViewWidth/5; if(mTranslate&gt;2*mViewWidth)&#123; mTranslate=-mViewWidth; &#125; mGradientMatrix.setTranslate(mTranslate,0); mLinearGradient.setLocalMatrix(mGradientMatrix); postInvalidateDelayed(100); &#125;&#125; 复合控件继承ViewGroup 定义属性 res/value/attrs.xml 123456789101112&lt;declare-styleable name=&quot;V&quot;&gt; &lt;attr name=&quot;title|size|background&quot; format=&quot;string|dimension| reference|color&quot;/&gt;&lt;/declare-styleable&gt;//获取TypedArray,存储了属性值TypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.V);ta.getColor();ta.getString();ta.getDrawable();ta.getDimension();//资源回收ta.recycle(); 组合控件 12345678mBtn1=new Button();mBtn2=new Button();mTextView=new TextView();mParams=new LayoutParams();mParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,true);addView(mBtn1,mParams);addView(mBtn2,mParams);addView(mTextView,mParams); 定义接口,添加事件 public method include layout 重写View 比例图 中间圆形加中心文字，外圈一定比例的圆弧 length 正方形边长 1234567891011- 圆 mCircle=length/2；mRadius=length/4; drawCirle()- 圆弧//所处的矩形框mRect=new Rect(0.1*length,0.1*length,0.9*length,0.9*length);drawArc(mRect,270,mSweepAngle,false,mArcPaint);- 文字drawText();setSweepValue(100); 音频条形图 onSizeChanged()设置渐变色 onDraw() 绘制多个小矩形 postInvalidateDelayed(300) 123456789101112131415161718192021222324252627282930@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); Log.e(&quot;Audio&quot;, &quot;mWidth=&quot; + mWidth + &quot; w=&quot; + w + &quot; h=&quot; + h + &quot; oldw=&quot; + oldw + &quot; oldh=&quot; + oldh); mRectHeight = getHeight(); mRectWidth = (int) (mWidth * 0.6 / mCount); mLinearGradient = new LinearGradient(0, 0, mRectWidth, mRectHeight, Color.YELLOW, Color.RED, Shader.TileMode.CLAMP); mMatrix = new Matrix(); mPaint.setShader(mLinearGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mTranslate += mRectWidth / 5; if (mTranslate &gt; 2 * mRectWidth) &#123; mTranslate = -mRectWidth; &#125; mMatrix.setTranslate(mTranslate, 0); mLinearGradient.setLocalMatrix(mMatrix); for (int i = 0; i &lt; mCount; i++) &#123; mCurrentHeight = (float) (mRectHeight * Math.random()); canvas.drawRect((float) (mWidth * 0.2 + offset + mRectWidth * i), mCurrentHeight, (float) (mWidth * 0.2 + mRectWidth * (i + 1)), mRectHeight, mPaint); &#125; postInvalidateDelayed(300);&#125; 自定义ViewGroup 重写onMeasure() onLayout() onTouchEvent() 自定义ScrollView，滑动后回位到item的起始位置 遍历的方式通知子View对自身测量 1234567891011121314private void init() &#123; mScroller = new OverScroller(getContext()); mScreenHeight = getResources().getDisplayMetrics().heightPixels; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int count=getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View child=getChildAt(i); measureChild(child,widthMeasureSpec,heightMeasureSpec); &#125; &#125; 对子View进行位置放置 123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); int screenHeight = getResources().getDisplayMetrics().heightPixels; //获取整个ViewGroup高度 MarginLayoutParams layoutParams = (MarginLayoutParams) getLayoutParams(); layoutParams.height = childCount * screenHeight; setLayoutParams(layoutParams); for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() != View.GONE) &#123; child.layout(l, screenHeight * i, r, screenHeight * (i + 1)); &#125; &#125;&#125; 在onTouchEvent()中添加滑动事件，使用scrollBy() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mLastY = event.getY(); //起点 mStart = getScrollY(); break; case MotionEvent.ACTION_MOVE: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; float dy = mLastY - event.getY(); Log.d(&quot;Scroll&quot;, &quot;======&quot; ); Log.d(&quot;Scroll&quot;, &quot;dy = &quot; + dy); Log.d(&quot;Scroll&quot;, &quot;getScrollY() = &quot; + getScrollY()); Log.d(&quot;Scroll&quot;, &quot;getHeight() = &quot; + getHeight()); Log.d(&quot;Scroll&quot;, &quot;mScreenHeight() = &quot; + mScreenHeight); Log.d(&quot;Scroll&quot;, &quot;getHeight() - mScreenHeight = &quot; + (getHeight() - mScreenHeight)); Log.d(&quot;Scroll&quot;, &quot;mLastY = &quot; + mLastY); Log.d(&quot;Scroll&quot;, &quot;mStart = &quot; + mStart); if (getScrollY() &lt; 0) &#123; //最顶端，超过0时，不再下拉 //不设置这个，getScrollY一直是负数 dy = 0; &#125; if (getScrollY() &gt; getHeight() - mScreenHeight) &#123; //滑到最底端时，不再滑动 //不设置这个，getScrollY一直是大于getHeight() - mScreenHeight的数 dy = 0; &#125; scrollBy(0, (int) dy); //不断的设置Y，在滑动的时候子view就会比较顺畅 mLastY = event.getY(); break; case MotionEvent.ACTION_UP: mEnd = getScrollY(); int dScrollY = mEnd - mStart; //向上，向下滑动，超过1/3屏幕高度， //结束滑动时滚动到下个位置，没有超过时复位 if (dScrollY &gt; 0) &#123; if (dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll(0, mEnd, 0, -dScrollY, 200); &#125; else &#123; mScroller.startScroll(0, mEnd, 0, mScreenHeight - dScrollY, 200); &#125; &#125; else &#123; if (-dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll(0, mEnd, 0, -dScrollY, 200); &#125; else &#123; mScroller.startScroll(0, mEnd, 0, -(mScreenHeight + dScrollY), 200); &#125; &#125; break; &#125; // 重绘执行computeScroll() postInvalidate(); //需要返回true否则down后无法执行move和up操作 return true;&#125;/** * Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性， * 但它并不是UI，也不是滑动辅助UI运动，反而是单纯地为滑动提供计算 * 需要invalidate()之后才会调用,这个方法在onDraw()中调用 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; scrollTo(0, mScroller.getCurrY()); postInvalidate(); &#125;&#125; 事件拦截机制，涉及触摸事件MotionEvent(),onTouchEvent()，dispatchTouchEvent(),onInterceptTouchEvent(),多个View,ViewGroup之间对事件的处理 ViewGroup A,B 1234567891011121314151617@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;dispatchTouchEvent &quot;+ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;onInterceptTouchEvent &quot;+ev.getAction()); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; Log.e(&quot;A&quot;,&quot;onTouchEvent &quot;+ev.getAction()); return super.onTouchEvent(ev);&#125; View 1234567891011@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;MyView&quot;,&quot;dispatchTouchEvent &quot;+ev.getAction()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; Log.e(&quot;MyView&quot;,&quot;onTouchEvent &quot;+ev.getAction()); return super.onTouchEvent(ev); &#125; View位置顺序是A最外层，B中间，MyView最底层。传递分发机制是A-&gt;B-&gt;MyView,处理机制时MyView-&gt;B-&gt;A 123事件传递返回值：True 拦截，不继续传递；False,不拦截，继续传递事件处理返回值：True 处理了不用传递回上级，False 给上级处理初始情况都是False]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sh 简单程序]]></title>
    <url>%2F2018%2F02%2F24%2Fsh-%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sh-demo 直接执行命令123datewho 创建变量，如果是字符串的话，有空格的一定要用双引号，否则会被解析成命令123NDK=10text=&quot;i love you&quot; 命令的执行结果作为变量的值，例如以当前时间作为文件名123text1=datetext2=$(who) 输出1234567echo $NDKecho $textecho $text1echo $text2 字符串拼接，同理：有空格需要用双引号1echo &quot;$text very much&quot; 如果需要输出$的话，需要使用转义字符1echo &quot;$&quot; 运行两种方式 1 ./bash.sh 2 sh bash.sh 如果sh command not found 或者 sh cannot open file 程序中的/r/n 换行符限制 命令退出的状态 命令执行退出的状态： 0 成功 127 没有找到命令 1 未知错误 126 命令不可执行 查看与退出状态指定： 查看上一次命令的执行状态echo $?在shell脚本中，自己指定退出的状态exit 状态码 grep命令是查找命令，例如查找test文本在test.txt中所在的行数：grep -n test test.txt 可以结合test命令，如果条件成立，test命令以状态为0退出，if条件成立。 test命令简单形式，用中括号，注意空格要加上 a -gt b 要加上空格,程序才能运行 比较大小： #!/bin/bash a=10b=5 test命令简单形式 if [ a -gt b ] then echo &quot;a greater than b&quot; else echo &quot;a smaller than b&quot; fi test数值比较： -gt 大于 -eq 等于 -le 小于 -ne 不等于 判空： #!/bin/bash str1=””if [ str1 = “” ] then echo &quot;有内容&quot;else echo &quot;没内容&quot;fi test字符串比较： str1 == str2 str1 != str2 str1 &lt; str2 -n str1 长度是否非0 -z str1 长度是否为0 检查目录是否存在： #!/bin/bash mydir=/usr/jason -d检查目录是否存在 if [ -d $mydir ] then echo &quot;$mydir exist&quot; cd $mydir ls else echo &quot;mydir not exist&quot; fi test文件比较： -d 检查是否存在，并且是一个目录 -e 检查file是否存在 -f 检查是否存在，并且是一个文件 -r 检查是否存在，并且可读，余此类推：-w、-x file1 -nt file2 file1比file2新 file1 -ot file2 file1比file2旧 case语句 基本格式是： case命令case 变量 inpattern1) 命令;;pattern2) 命令;;*) 默认命令;;esac 例子： #!/bin/bash testuser=rose case $testuser in rose) echo &quot;hi,$testuser&quot;;; ricky) echo &quot;hello, ricky&quot;;; *) echo &quot;defaults&quot;;; esac While循环 基本格式： while test command（或者[]）do 命令done 例子： #!/bin/bash a=10 while [ $a -gt 0 ] do echo &quot;num:$a&quot; 赋值不用使用$符号 a=[ a - 1 ]done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用快捷键 命令 设置等操作]]></title>
    <url>%2F2018%2F02%2F24%2FLinux-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常用快捷键 Ctrl+Alt+T 打开终端 Ctrl+L 清空屏幕(功能相当于命令clear) Ctrl+U 剪切文本直到行的起始(可以用于清空行) Ctrl+K 剪切文本直到行的末尾 Ctrl+Y 粘贴最近剪切的文本 Ctrl+C 杀死当前进程(也可以用来清空当前行) Ctrl+D 退出当前Shell(功能相当于命令exit) 或者 删除当前的字符 Ctrl+A 行首 Ctrl+E 行尾 Home/End 行首/行尾 Ctrl+F 向前移动一个字符 Ctrl+B 向后移动一个字符 Ctrl+P 或 Ctrl+N 上下历史记录 上下方向键 上下历史记录 Ctrl+Shift+C 复制 Ctrl+Shift+V 粘贴 还有Tab补全,按住Ctrl键进行块选择. 鼠标中键:粘贴(在gnome-terminal中使用”菜单 键+P”也是可以粘贴的) 设置代理1.通过export http代理使用apt-get（临时有效）在使用apt-get之前，在终端中输入以下命令 12export http_proxy=&quot;&quot;export https_proxy=&quot;&quot; 2.apt.conf文件中配置http代理信息（永久有效） sudo gedit /etc/apt/apt.conf在您的apt.conf文件中加入下面这行1Acquire::http::Proxy &quot;http://proxy_addr:proxy_port&quot;; 3..bashrc文件中配置代理信息(apt-get, wget 等等)（全局有效） gedit ~/.bashrc 在.bashrc文件末尾添加如下内容1export http_proxy=&quot;http://proxy_addr:proxy_port&quot; vi操作 跳到文本的最后一行：按“G”,即“shift+g” 跳到最后一行的最后一个字符 ： 先重复1的操作即按“G”，之后按“$”键，即“shift+4”。 跳到第一行的第一个字符：先按两次“g”， 跳转到当前行的第一个字符：在当前行按“0”。 vi加密。进入vi，输入”:” + “X” 之后就提示你输入两次密码。之后:wq 保存退出。再次进入时就提示你输入密码了。如果你不想要密码了，就:X 提示你输入密码时连续按两次回车 编辑只读文件存在历史，buffer状态等，不能直接修改保存文件，解决方案1:w !sudo tee % 设置环境变量12345678910111213141516vim .bashrc echo $PATH (列出所有环境变量) echo $JAVA_HOME （列出某个环境变量值） source .bashrc (保存并且生效) NDKROOT=&apos;/home/willkernel/Downloads/android-ndk-r15c&apos;export NDKROOTexport PATH=$NDKROOT:$PATHANDROID=&apos;/home/willkernel/Downloads/android-studio/bin&apos;export ANDROIDexport PATH=$ANDROID:$PATHFFMPEG=&apos;/home/willkernel/Downloads/ffmpeg-2.6.9&apos;export FFMPEGexport PATH=$FFMPEG:$PATH 常用命令50 Most Frequently Used UNIX / Linux Commands (With Examples)50个最常用的Unix/Linux命令 其他 install lantern in Ubuntu and launch lanternsudo dpkg -i lantern *.deb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
</search>
